#lang racket

(require
  syntax/parse/define
  "expander.rkt"
  "std.rkt"
  (prefix-in stx/ "syntax.rkt")
  (for-syntax
    racket
    threading
    racket/function
    racket/syntax
    syntax/parse
    syntax/parse/define
    "scope.rkt"
    (prefix-in meta/ "meta.rkt")))

(provide begin-hydromel)

(define-syntax-parse-rule (begin-hydromel body ...)
  (begin
    (compile-as-module-level-defs body) ...
    (compile-hydromel body ...)))

; First pass: bind module-level elements and manage module imports.
(define-syntax-parser compile-as-module-level-defs
  [(_ s:stx/import)
   (if (attribute s.name)
     (let ([prefix (format-id #'s.name "~a::" #'s.name)])
       #`(require (prefix-in #,prefix s.path)))
     #'(require s.path))]

  [(_ s:stx/constant)
   #:with alt-name (generate-temporary (format-id #'s.name "hdrml:constant:~a" #'s.name))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/constant #t)))]

  [(_ s:stx/interface)
   #:with (p ...) (design-unit-field-metadata (attribute s.body))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/make-interface (list p ...))))]

  [(_ s:stx/component)
   #:with (p ...) (design-unit-field-metadata (attribute s.body))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/make-component (list p ...))))]

  [_
   #'(begin)])

; Second pass:  create the scope hierarchy and bindings to local metadata (see make-checker).
; Third pass: perform semantic checking (see thunks generated by make-checker).
(define-syntax (compile-hydromel stx)
  (define/syntax-parse (_ body ...) stx)
  ((make-checker stx)))

(begin-for-syntax
  (define (boolean->syntax b)
    (if b #'#t #'#f))

  ; First pass: fill the metadata of module-level elements.
  ; Those metadata are constructed as syntax objects that will be inserted
  ; into the result of compile-as-module-level-defs.
  (define (design-unit-field-metadata lst)
    (filter identity
      (for/list ([stx (in-list lst)])
        (syntax-parse stx
          [s:stx/data-port
           #'(cons 's.name (meta/data-port 's.mode))]
          [s:stx/composite-port
           #:with flip   (boolean->syntax (attribute s.flip?))
           #:with splice (boolean->syntax (attribute s.splice?))
           #'(cons 's.name (meta/composite-port #'s.intf-name flip splice))]
          [s:stx/constant
           #'(cons 's.name (meta/constant #f))]
          [_ #f]))))

  (define current-design-unit (make-parameter #f))

  (define (check-all lst)
    (map (λ (f) (f)) lst))

  ; Second pass:  create the scope hierarchy and bindings to local metadata.
  ; Third pass: perform semantic checking in returned thunks.
  (define (make-checker stx)
    (syntax-parse stx
      #:literals [compile-hydromel]

      [(compile-hydromel body ...)
       (define body^ (map make-checker (attribute body)))
       (thunk
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (begin body ...)))]

      [s:stx/import
       (thunk #'(begin))]

      [s:stx/interface
       (define body^
         (parameterize ([current-design-unit (lookup #'s.name)])
           (with-scope
             (~>> (attribute s.body)
                  (create-aliases)
                  (map add-scope)
                  (map make-checker)))))
       (thunk
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (interface s.name body ...)))]

      [s:stx/component
       (define body^
         (parameterize ([current-design-unit (lookup #'s.name)])
           (with-scope
             (~>> (attribute s.body)
                  (create-aliases)
                  (map add-scope)
                  (map make-checker)))))
       (thunk
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (component s.name body ...)))]

      [s:stx/parameter
       #:with name (bind! #'s.name (meta/parameter))
       (define type^ (make-checker #'s.type))
       (thunk/in-scope
         (define/syntax-parse type (type^))
         (syntax/loc stx
           (parameter name type)))]

      [s:stx/constant
       #:with name (if (current-design-unit)
                     (bind! #'s.name (meta/design-unit-ref (current-design-unit) #'s.name))
                     #'s.name)
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse expr (expr^))
         ; Check that the expression has a static value.
         (unless (static? #'expr)
           (raise-syntax-error #f "Non-static expression cannot be assigned to constant" #'s.expr))
         (syntax/loc stx
           (constant name expr)))]

      [s:stx/data-port
       #:with name (bind! #'s.name (meta/design-unit-ref (current-design-unit) #'s.name))
       (define type^ (make-checker #'s.type))
       (thunk/in-scope
         (define/syntax-parse type (type^))
         (syntax/loc stx
           (data-port name s.mode type)))]

      [s:stx/composite-port
       #:with name (bind! #'s.name (meta/design-unit-ref (current-design-unit) #'s.name))
       (define mult^ (make-checker (or (attribute s.mult) #'(literal-expr 1))))
       (define args^ (map make-checker (attribute s.arg)))
       (thunk/in-scope
         ; Check that the multiplicity has a static value.
         (define/syntax-parse mult (mult^))
         (unless (static? #'mult)
           (raise-syntax-error #f "Non-static expression cannot be used as instance multiplicity" #'s.mult))
         ; Check that intf-name refers to an existing interface
         (lookup #'s.intf-name meta/interface?)
         ; Check arguments
         (define/syntax-parse (arg ...) (check-all args^))
         (syntax/loc stx
           (composite-port name (multiplicity mult) s.mode ... s.intf-name arg ...)))]

      [s:stx/instance
       #:with name (bind! #'s.name (meta/instance #'s.comp-name))
       (define mult^ (make-checker (or (attribute s.mult) #'(literal-expr 1))))
       (define args^ (map make-checker (attribute s.arg)))
       (thunk/in-scope
         ; Check that the multiplicity has a static value.
         (define/syntax-parse mult (mult^))
         (unless (static? #'mult)
           (raise-syntax-error #f "Non-static expression cannot be used as instance multiplicity" #'s.mult))
         ; Check that comp-name refers to an existing component
         ; Check arguments
         (define/syntax-parse (arg ...) (check-all args^))
         (syntax/loc stx
           (instance name (multiplicity mult) s.comp-name arg ...)))]

      [s:stx/local-signal
       #:with name (bind! #'s.name (meta/local-signal))
       (define type^ (and (attribute s.type) (make-checker #'s.type)))
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         ; TODO check expression type
         (define/syntax-parse expr (check-assigned-expr (expr^)))
         (if type^
           (syntax-parse (type^)
             [type (syntax/loc stx
                     (local-signal name type expr))])
           (syntax/loc stx
             (local-signal name expr))))]

      [s:stx/assignment
       ; TODO check circular dependencies.
       (define target^ (make-checker #'s.target))
       (define expr^   (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse target (target^))
         (define/syntax-parse expr   (expr^))
         (define target-port (check-assignment-target #'target))
         (if (meta/composite-port? target-port)
           ; If the left-hand side is a composite port, generate a connect statement.
           (let ([expr-port (resolve #'expr)])
             (unless (meta/composite-port? expr-port)
               (raise-syntax-error #f "Right-hand side of assignment is not a composite port" #'expr))
             (unless (equal? (syntax-e (meta/composite-port-intf-name target-port))
                             (syntax-e (meta/composite-port-intf-name expr-port)))
               (raise-syntax-error #f "Right-hand side and left-hand side of assignment have different interfaces" stx))
             (syntax/loc stx
               (connect-statement target expr)))
           ; If the left-hand side is a signal, generate an assignment statement.
           (quasisyntax/loc stx
               (assignment target #,(check-assigned-expr #'expr)))))]

      [s:stx/if-statement
       #:with name (or (attribute s.name) (generate-temporary #'if))
       (define conditions^  (map make-checker (attribute s.condition)))
       (define then-bodies^ (map make-checker (attribute s.then-body)))
       (define else-body^   (make-checker     #'s.else-body))
       (thunk/in-scope
         (define/syntax-parse (condition ...) (check-all conditions^))
         (for ([it (in-list (attribute condition))]
               #:unless (static? it))
           (raise-syntax-error #f "Non-static expression cannot be used in range" it))
         (define/syntax-parse (then-body ...) (check-all then-bodies^))
         (define/syntax-parse else-body       (else-body^))
         (syntax/loc stx
           (if-statement name (~@ condition then-body) ... else-body)))]

      [s:stx/for-statement
       #:with name (or (attribute s.name) (generate-temporary #'if))
       (define expr^ (make-checker #'s.expr))
       ; The loop counter is bound as a constant inside a new scope
       ; so that only the loop body can use it.
       (define-values (iter-name body^)
         (with-scope
           (values
             (bind! #'s.iter-name (meta/constant #f))
             (~> #'s.body
                 add-scope
                 make-checker))))
       (thunk/in-scope
         (define/syntax-parse expr (expr^))
         (define/syntax-parse body (body^))
         (unless (static? #'expr)
           (raise-syntax-error #f "Non-static expression cannot be used as loop range" #'expr))
         (quasisyntax/loc stx
           (for-statement name #,iter-name expr body)))]


      [s:stx/statement-block
       (define body^ (with-scope
                       (~>> (attribute s.body)
                            (map add-scope)
                            (map make-checker))))
       (thunk
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (statement-block body ...)))]

      [s:stx/field-expr
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse expr (expr^))
         (define-values (type-name type) (check-field-expr #'expr #'s.field-name))
         (if (meta/record-type? type)
           (quasisyntax/loc stx
             (field-expr expr s.field-name #,type-name))
           (syntax/loc stx
             (field-expr expr s.field-name))))]

      [s:stx/indexed-expr
       (define expr^ (make-checker #'s.expr))
       (define indices^ (map make-checker (attribute s.index)))
       (thunk
         ; TODO support indexed access to array data types.
         (define/syntax-parse expr (expr^))
         (define r (resolve #'expr))
         (unless (or (meta/composite-port? r) (meta/instance? r))
           (raise-syntax-error #f "Expression not suitable for indexing" #'s.expr))
         (define/syntax-parse (index ...) (check-all indices^))
         (syntax/loc stx
           (indexed-expr expr index ...)))]

      [s:stx/register-expr
       (define init-expr^   (make-checker #'s.init-expr))
       (define init-cond^   (and (attribute s.init-cond) (make-checker #'s.init-cond)))
       (define update-expr^ (make-checker #'s.update-expr))
       (define update-cond^ (and (attribute s.update-cond) (make-checker #'s.update-cond)))
       (thunk
         (define init-expr (init-expr^))
         (unless (static? init-expr)
           (raise-syntax-error #f "Non-static expression cannot be used as an initial register value" #'s.init-expr))
         (define/syntax-parse (arg ...) (filter identity
                                          (list
                                            init-expr
                                            (and init-cond^ (init-cond^))
                                            (check-assigned-expr (update-expr^))
                                            (and update-cond^ (update-cond^)))))
         (syntax/loc stx
           (register-expr arg ...)))]

      [s:stx/when-clause
       (define expr^ (make-checker #'(call-expr int-to-bool s.expr)))
       (thunk
         (define/syntax-parse expr (check-assigned-expr (expr^)))
         (syntax/loc stx
           (when-clause expr)))]

      [s:stx/call-expr
       (define args^ (map make-checker (attribute s.arg)))
       (thunk
         ; TODO check that fn is a built-in or custom function.
         (define fn (lookup #'s.fn-name))
         (define/syntax-parse fn-name (if (meta/builtin-function? fn)
                                        (meta/builtin-function-name fn)
                                        #'s.fn-name))
         (define/syntax-parse (arg ...) (check-all args^))
         ; Bitwise concatenation is a special case where we interleave
         ; argument values with their inferred types.
         (define/syntax-parse (arg+ ...)
           (if (equal? (syntax->datum #'s.fn-name) 'kw-concat)
             #'((~@ arg (infer-type arg)) ...)
             #'(arg ...)))
         (syntax/loc stx
           (call-expr fn-name arg+ ...)))]

      [s:stx/name-expr
       (thunk
         (match (lookup #'s.name)
           ; A function name is converted to a function call with no argument.
           [(meta/builtin-function fn-name)
            (quasisyntax/loc stx
              (call-expr #,fn-name))]

           ; For a global constant name, append a suffix to access the actual constant.
           [(meta/constant #t)
            (syntax/loc stx
              (name-expr s.name -constant))]

           [else stx]))]

      [_ (thunk stx)]))

  ; Returns a list of ports in interface intf after splicing.
  (define (splice-interface intf flip?)
    (apply append
      (for/list ([(field-name field) (in-dict (meta/design-unit-fields intf))])
        (cons
          (cons field-name (if flip? (meta/flip-port field) field))
          (if (and (meta/composite-port? field) (meta/composite-port-splice? field))
            (~> field
                (meta/composite-port-intf-name)
                (lookup meta/interface?)
                (splice-interface (xor flip? (meta/composite-port-flip? field))))
            empty)))))

  ; Insert aliases for the spliced composite ports in the given list.
  (define (create-aliases lst)
    (apply append
      (for/list ([stx (in-list lst)])
        (cons stx
              (syntax-parse stx
                [s:stx/composite-port #:when (attribute s.splice?)
                 (define intf (lookup #'s.intf-name meta/interface?))
                 (for/list ([(port-name p) (in-dict (splice-interface intf (attribute s.flip?)))])
                   (define/syntax-parse port-name^ (bind! (datum->syntax stx port-name) p))
                   #'(alias port-name^ s.name))]
                [_ empty])))))

  ; Check whether stx is an expression with a static value.
  ; Returns true when stx is:
  ; - a literal expression,
  ; - a name expression that refers to a constant or a parameter,
  ; - a field expression whose left-hand side has a static value,
  ; - an indexed expression whose left-hand side and indices have static values,
  ; - a call whose arguments have static values.
  (define (static? stx)
    (syntax-parse stx
      [s:stx/literal-expr #t]
      [s:stx/name-expr    (define c (lookup #'s.name)) (or (meta/constant? c) (meta/parameter? c))]
      [s:stx/field-expr   (or  (static? #'s.expr) (meta/constant? (resolve stx)))]
      [s:stx/indexed-expr (and (static? #'s.expr) (andmap static? (attribute s.index)))]
      [s:stx/call-expr    (andmap static? (attribute s.arg))]
      [_                  #f]))

  ; Find the metadata of the given expression result.
  (define (resolve stx)
    (syntax-parse stx
      [s:stx/name-expr
       ; For a name expression, lookup the metadata in the current scope.
       (lookup #'s.name)]

      [s:stx/field-expr
       ; For a field expression, resolve the left-hand side first.
       (match (resolve #'s.expr)
         [(meta/composite-port intf-name _ _)
          ; If the lhs maps to a composite port, look up the given field name
          ; in the target interface.
          (meta/design-unit-ref (lookup intf-name meta/interface?) #'s.field-name)]

         [(meta/instance comp-name)
          ; If the lhs maps to an instance, look up the given field name
          ; in the target component.
          (meta/design-unit-ref (lookup comp-name meta/component?) #'s.field-name)]

         ; TODO resolve field access for structured data types

         [_ (raise-syntax-error #f "Expression not suitable for field access" stx)])]

      [s:stx/indexed-expr
       ; For an indexed expression, the metadata are those of the left-hand side.
       (resolve #'s.expr)]

      [_ #f]))

  ; Check an expression that appears in the left-hand side of an assignment.
  (define (check-assignment-target stx)
    (define target (resolve stx))
    (match target
      ; If the left-hand side of an assignment resolves to a data port,
      ; check the mode of this port.
      [(meta/data-port mode)
       (define (flip? stx [res #f])
         (syntax-parse stx
           [s:stx/field-expr
            (define res^ (flip? #'s.expr res))
            (match (resolve #'s.expr)
              [(meta/composite-port _ f? _) (xor f? res^)]
              [(meta/instance _) (not res^)])]
           [_ res]))
       (unless (equal? mode (if (flip? stx) 'in 'out))
         (raise-syntax-error #f "Port cannot be assigned" stx))]

      [(meta/composite-port intf-name flip? splice?)
       (void)]

      [_ (raise-syntax-error #f "Expression not suitable as assignment target" stx)])
    target)

  (define-syntax-parse-rule (qs/l expr)
    (quasisyntax/loc this-syntax expr))

  ; Check an expression that constitutes the right-hand side of an assignment.
  ; This includes:
  ; - the expression assigned to a local signal,
  ; - the update clause of a register expression,
  ; - the when clauses of a register expression.
  ; Returns an expression wrapped in lift-expr, signal-expr, or slot-expr.
  (define (check-assigned-expr stx)
    (syntax-parse (lift-if-needed stx)
      [s:stx/lift-expr
       ; If a lift-expr wraps a signal read, wrap it also in a slot-expr.
       (if (meta/signal? (resolve #'s.expr))
         #'(lift-expr s.binding ... (slot-expr s.expr))
         this-syntax)]

      [_
       ; If stx has a static value, wrap it in a signal-expr.
       ; If stx resolves to a signal, wrap it in a slot-expr.
       (cond [(static? stx)                (qs/l (signal-expr #,stx))]
             [(meta/signal? (resolve stx)) (qs/l (slot-expr #,stx))]
             [else                         stx])]))

  (define (lift-if-needed stx)
    (syntax-parse stx
      #:literals [indexed-expr field-expr concat-expr]
      [(indexed-expr expr ...)
       (lift-if-needed* stx (attribute expr)
         (λ (lst) (qs/l (indexed-expr #,@lst))))]
      [(field-expr expr sel ...)
       (lift-if-needed* stx (list #'expr)
         (λ (lst) (qs/l (field-expr #,(first lst) sel ...))))]
      ; [(concat-expr arg ...)
      ;  (lift-if-needed* stx (attribute arg)
      ;    (λ (lst) (qs/l (call-expr kw-concat #,@lst))))]
      [s:stx/call-expr
       (lift-if-needed* stx (attribute s.arg)
         (λ (lst) (qs/l (call-expr s.fn-name #,@lst))))]
      [_
       stx]))

  (define (lift-if-needed* stx lst thunk)
    (for/foldr ([b-lst empty] ; The list of bindings for the new lift-expr
                [a-lst empty] ; The list of arguments for the new call-expr
                ; If there are no bindings, return the original call-expr,
                ; else, make a new call-expr wrapped in a lift-expr.
                #:result (if (empty? b-lst)
                           stx
                           (quasisyntax/loc stx
                             (lift-expr #,@b-lst #,(thunk a-lst)))))
                ; Lift each argument if needed before proceeding.
               ([a (in-list (map lift-if-needed lst))])
      (syntax-parse a
        [s:stx/lift-expr
         ; If the current argument is already lifted,
         ; accumulate its bindings and unwrap its expression.
         (values (append (attribute s.binding) b-lst)
                 (cons   #'s.expr              a-lst))]

        [_ #:when (meta/signal? (resolve a))
         ; If the argument resolves to a signal, wrap it in a slot-expr,
         ; create a binding and replace it with a name-expr.
         #:with bname (gensym "lift")
         (values (cons #`(bname (slot-expr #,a)) b-lst)
                 (cons #'(name-expr bname)         a-lst))]

        [_
         ; In the other cases, keep the current list of bindings
         ; and the current argument.
         (values b-lst (cons a a-lst))])))

  (define (check-field-expr expr field-name)
    (match (resolve expr)
      [(meta/composite-port intf-name _ _)
       ; Check that a port with that name exists in the interface.
       (define intf (lookup intf-name meta/interface?))
       (meta/design-unit-ref intf field-name)
       ; Return the interface name.
       (values intf-name intf)]

      [(meta/instance comp-name)
       ; Check that a port with that name exists in the component.
       (define comp (lookup comp-name meta/component?))
       (meta/design-unit-ref comp field-name)
       ; Return the component name.
       (values comp-name comp)]

      ; TODO support field access in structured types

      [_ (raise-syntax-error #f "Expression not suitable for field access" expr)])))


(module+ test
  (require
    rackunit
    "helpers.rkt"
    "signal.rkt"
    "std.rkt"
    "types.rkt"
    "slot.rkt")

  (define (check-sig-equal? t e n)
    (check-equal? (signal-take t n) (signal-take e n)))

  (begin-hydromel
    (component C0
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y out (call-expr signed (literal-expr 32)))
      (assignment (name-expr y) (name-expr x))))

  (define c0-inst (C0-make))
  (slot-set! (c0-inst x) (signal 10))

  (test-case "Can label a simple signal expressions"
    (check-sig-equal? (slot-ref c0-inst y) (slot-ref c0-inst x) 5))

  (begin-hydromel
    (interface I0
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y out (call-expr signed (literal-expr 32))))

    (component C1
      (composite-port i I0)
      (assignment (field-expr (name-expr i) y) (field-expr (name-expr i) x))))

  (define c1-inst (C1-make))
  (slot-set! (c1-inst i x) (signal 10))

  (test-case "Can resolve ports in field expressions"
    (check-sig-equal? (slot-ref c1-inst i y) (slot-ref c1-inst i x) 5))

  (begin-hydromel
    (component C2
      (composite-port i (multiplicity (literal-expr 2)) I0)
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 1)) x))))

  (define c2-inst (C2-make))
  (slot-set! (c2-inst i 0 x) (signal 10))
  (slot-set! (c2-inst i 1 x) (signal 20))

  (test-case "Can resolve ports in indexed expressions"
    (check-sig-equal? (slot-ref c2-inst i 0 y) (slot-ref c2-inst i 0 x) 5)
    (check-sig-equal? (slot-ref c2-inst i 1 y) (slot-ref c2-inst i 1 x) 5))

  (begin-hydromel
    (interface I1
      (composite-port i (multiplicity (literal-expr 2)) I0))

    (component C3
      (composite-port j (multiplicity (literal-expr 2)) I1)
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 1)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 1)) x))))

  (define c3-inst (C3-make))
  (slot-set! (c3-inst j 0 i 0 x) (signal 10))
  (slot-set! (c3-inst j 0 i 1 x) (signal 20))
  (slot-set! (c3-inst j 1 i 0 x) (signal 30))
  (slot-set! (c3-inst j 1 i 1 x) (signal 40))

  (test-case "Can resolve ports in a hierarchy of expressions"
    (check-sig-equal? (slot-ref c3-inst j 0 i 0 y) (slot-ref c3-inst j 0 i 0 x) 5)
    (check-sig-equal? (slot-ref c3-inst j 0 i 1 y) (slot-ref c3-inst j 0 i 1 x) 5)
    (check-sig-equal? (slot-ref c3-inst j 1 i 0 y) (slot-ref c3-inst j 1 i 0 x) 5)
    (check-sig-equal? (slot-ref c3-inst j 1 i 1 y) (slot-ref c3-inst j 1 i 1 x) 5))

  (begin-hydromel
    (component C4
      (data-port x out (call-expr signed (literal-expr 32)))
      (assignment (name-expr x) (literal-expr 10))))

  (define c4-inst (C4-make))

  (test-case "Can assign a literal to a signal"
    (check-sig-equal? (slot-ref c4-inst x) (signal 10) 5))

  (begin-hydromel
    (component C5
      (data-port x out (call-expr signed (literal-expr 32)))
      (constant k (literal-expr 10))
      (assignment (name-expr x) (name-expr k))))

  (define c5-inst (C5-make))

  (test-case "Can assign a constant to a signal"
    (check-sig-equal? (slot-ref c5-inst x) (signal 10) 5))

  (begin-hydromel
    (component C6
      (data-port x out (call-expr signed (literal-expr 32)))
      (constant k (literal-expr 10))
      (assignment (name-expr x) (add-expr (name-expr k) + (literal-expr 1)))))

  (define c6-inst (C6-make))

  (test-case "Can assign a static expression to a signal"
    (check-sig-equal? (slot-ref c6-inst x) (signal 11) 5))

  (begin-hydromel
    (component C7
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z out (call-expr signed (literal-expr 32)))
      (assignment (name-expr z)
        (call-expr cast
          (call-expr signed (literal-expr 32))
          (add-expr (name-expr x) + (name-expr y))))))

  (define c7-inst (C7-make))
  (slot-set! (c7-inst x) (signal 10 20 30))
  (slot-set! (c7-inst y) (signal 40 50 60))

  (test-case "Can lift an operation"
    (check-sig-equal? (slot-ref c7-inst z) (signal 50 70 90) 5))

  (begin-hydromel
    (component C8
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z in (call-expr signed (literal-expr 32)))
      (data-port u in (call-expr signed (literal-expr 32)))
      (data-port v out (call-expr signed (literal-expr 32)))
      (assignment (name-expr v)
        (call-expr cast
          (call-expr signed (literal-expr 32))
          (add-expr (mult-expr (name-expr x) * (name-expr y))
                  + (mult-expr (name-expr z) * (name-expr u)))))))

  (define c8-inst (C8-make))
  (slot-set! (c8-inst x) (signal 10 20 30 40 50))
  (slot-set! (c8-inst y) (signal 2))
  (slot-set! (c8-inst z) (signal 1 2 3 4 5))
  (slot-set! (c8-inst u) (signal 3))

  (test-case "Can lift nested calls"
    (check-sig-equal? (slot-ref c8-inst v) (signal 23 46 69 92 115) 5))

  (begin-hydromel
    (component C9
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z in (call-expr signed (literal-expr 32)))
      (data-port u in (call-expr signed (literal-expr 32)))
      (data-port v out (call-expr signed (literal-expr 32)))
      (local-signal xy (mult-expr (name-expr x) * (name-expr y)))
      (local-signal zu (mult-expr (name-expr z) * (name-expr u)))
      (assignment (name-expr v)
        (call-expr cast
          (call-expr signed (literal-expr 32))
          (add-expr (name-expr xy) + (name-expr zu))))))

  (define c9-inst (C9-make))
  (slot-set! (c9-inst x) (signal 10 20 30 40 50))
  (slot-set! (c9-inst y) (signal 2))
  (slot-set! (c9-inst z) (signal 1 2 3 4 5))
  (slot-set! (c9-inst u) (signal 3))

  (test-case "Can use local signals"
    (check-sig-equal? (slot-ref c9-inst v) (signal 23 46 69 92 115) 5))

  (begin-hydromel
    (interface I2
      (data-port x in (call-expr signed (literal-expr 32))))

    (component C10
      (composite-port i (multiplicity (literal-expr 3)) I2)
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z out (call-expr signed (literal-expr 32)))
      (assignment (name-expr z)
                  (field-expr (indexed-expr (name-expr i) (name-expr y)) x))))

  (define c10-inst (C10-make))
  (slot-set! (c10-inst i 0 x) (signal 10))
  (slot-set! (c10-inst i 1 x) (signal 20))
  (slot-set! (c10-inst i 2 x) (signal 30))
  (slot-set! (c10-inst y)     (signal 0 1 2 1 0 2))

  (test-case "Can access simple ports in a vector composite port with dynamic indices"
    (check-sig-equal? (slot-ref c10-inst z) (signal 10 20 30 20 10 30) 5))

  (begin-hydromel
    (component C11
      (parameter N (call-expr unsigned (literal-expr 32)))
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y out (call-expr signed (literal-expr 32)))
      (assignment (name-expr y)
        (call-expr cast
          (call-expr signed (literal-expr 32))
          (mult-expr (name-expr x) * (name-expr N)))))

    (component C12
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y out (call-expr signed (literal-expr 32)))
      (instance c C11 (literal-expr 10))
      (assignment (field-expr (name-expr c) x) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) y))))

  (define c12-inst (C12-make))
  (slot-set! (c12-inst x) (signal 10 20 30 40 50))

  (test-case "Can instantiate a component"
    (check-sig-equal? (slot-ref c12-inst y) (signal 100 200 300 400 500) 5))

  (begin-hydromel
    (component C13
      (data-port x0 in (call-expr signed (literal-expr 32)))
      (data-port x1 in (call-expr signed (literal-expr 32)))
      (data-port y out (call-expr signed (literal-expr 32)))
      (instance c (multiplicity (literal-expr 2)) C11 (literal-expr 10))
      (assignment (field-expr (indexed-expr (name-expr c) (literal-expr 0)) x) (name-expr x0))
      (assignment (field-expr (indexed-expr (name-expr c) (literal-expr 1)) x) (name-expr x1))
      (assignment (name-expr y)
        (call-expr cast
          (call-expr signed (literal-expr 32))
          (add-expr (field-expr (indexed-expr (name-expr c) (literal-expr 0)) y)
                  + (field-expr (indexed-expr (name-expr c) (literal-expr 1)) y))))))

  (define c13-inst (C13-make))
  (slot-set! (c13-inst x0) (signal 10 20 30 40 50))
  (slot-set! (c13-inst x1) (signal 1  2  3  4  5))

  (test-case "Can instantiate a multiple component"
    (check-sig-equal? (slot-ref c13-inst y) (signal 110 220 330 440 550) 5))

  (begin-hydromel
    (component C14
      (composite-port i splice I0)
      (assignment (name-expr y) (name-expr x))))

  (define c14-inst (C14-make))
  (slot-set! (c14-inst x) (signal 10))

  (test-case "Can resolve ports in a spliced interface"
    (check-sig-equal? (slot-ref c14-inst y) (slot-ref c14-inst x) 5))

  (begin-hydromel
    (component C15
      (composite-port i splice flip I0)
      (assignment (name-expr x) (name-expr y))))

  (define c15-inst (C15-make))
  (slot-set! (c15-inst y) (signal 10))

  (test-case "Can resolve ports in a spliced flipped interface"
    (check-sig-equal? (slot-ref c15-inst x) (slot-ref c15-inst y) 5))

  (begin-hydromel
    (component C16
      (composite-port j splice I1)
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 1)) x))))

  (define c16-inst (C16-make))
  (slot-set! (c16-inst i 0 x) (signal 10))
  (slot-set! (c16-inst i 1 x) (signal 20))

  (test-case "Can resolve ports in a hierarchy from a spliced interface"
    (check-sig-equal? (slot-ref c16-inst i 0 y) (slot-ref c16-inst i 0 x) 5)
    (check-sig-equal? (slot-ref c16-inst i 1 y) (slot-ref c16-inst i 1 x) 5))

  (begin-hydromel
    (interface I3
      (composite-port i splice I0))

    (component C17
      (composite-port j splice I3)
      (assignment (name-expr y) (name-expr x))))

  (define c17-inst (C17-make))
  (slot-set! (c17-inst j x) (signal 10))

  (test-case "Can resolve ports in an interface with a spliced composite port"
    (check-sig-equal? (slot-ref c17-inst j y) (slot-ref c17-inst j x) 5))

  (test-case "Can resolve ports in a doubly spliced composite port"
    (check-sig-equal? (slot-ref c17-inst y) (slot-ref c17-inst x) 5))

  (begin-hydromel
    (component C18
      (composite-port j splice flip I3)
      (assignment (name-expr x) (name-expr y))))

  (define c18-inst (C18-make))
  (slot-set! (c18-inst y) (signal 10))

  (test-case "Can resolve ports in a doubly spliced flipped-last composite port"
    (check-sig-equal? (slot-ref c18-inst x) (slot-ref c18-inst y) 5))

  (begin-hydromel
    (interface I4
      (composite-port i splice flip I0))

    (component C19
      (composite-port j splice I4)
      (assignment (name-expr x) (name-expr y))))

  (define c19-inst (C19-make))
  (slot-set! (c19-inst y) (signal 10))

  (test-case "Can resolve ports in a doubly spliced flipped-first composite port"
    (check-sig-equal? (slot-ref c19-inst x) (slot-ref c19-inst y) 5))

  (begin-hydromel
    (component C20
      (composite-port j splice flip I4)
      (assignment (name-expr y) (name-expr x))))

  (define c20-inst (C20-make))
  (slot-set! (c20-inst x) (signal 10))

  (test-case "Can resolve ports in a doubly spliced doubly-flipped composite port"
    (check-sig-equal? (slot-ref c20-inst y) (slot-ref c20-inst x) 5))

  (begin-hydromel
    (component C21
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z out (call-expr signed (literal-expr 32)))
      (assignment (name-expr z) (if-expr (rel-expr (name-expr x) > (name-expr y))
                                  (name-expr x)
                                  (name-expr y)))))

  (define c21-inst (C21-make))
  (slot-set! (c21-inst x) (signal 10 20  30  40 50))
  (slot-set! (c21-inst y) (signal 1  200 300 4  5))

  (test-case "Can compute a conditional signal"
    (check-sig-equal? (slot-ref c21-inst z) (signal 10 200 300 40 50) 5))

  (begin-hydromel
    (component C22
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y out (call-expr signed (literal-expr 32)))
      (assignment (name-expr y) (register-expr (literal-expr 0) (name-expr x)))))

  (define c22-inst (C22-make))
  (slot-set! (c22-inst x) (signal 10 20  30 40 50))

  (test-case "Can register a signal"
    (check-sig-equal? (slot-ref c22-inst y) (signal 0  10 20 30 40 50) 6))

  (begin-hydromel
    (component C23
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z out (call-expr signed (literal-expr 32)))
      (assignment (name-expr z) (register-expr (literal-expr 0) (when-clause (name-expr x))
                                               (name-expr y)))))

  (define c23-inst (C23-make))
  (slot-set! (c23-inst x) (signal 0  0  0  1  0))
  (slot-set! (c23-inst y) (signal 10 20 30 40 50))

  (test-case "Can register a signal with reset"
    (check-sig-equal? (slot-ref c23-inst z) (signal 0  10 20 30 0  50) 6))

  (begin-hydromel
    (component C24
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z out (call-expr signed (literal-expr 32)))
      (assignment (name-expr z) (register-expr (literal-expr 0)
                                               (name-expr y) (when-clause (name-expr x))))))

  (define c24-inst (C24-make))
  (slot-set! (c24-inst x) (signal 0  1  0  1  0))
  (slot-set! (c24-inst y) (signal 10 20 30 40 50))

  (test-case "Can register a signal with enable"
    (check-sig-equal? (slot-ref c24-inst z) (signal 0  0  20 20 40) 6))

  (begin-hydromel
    (component C25
      (data-port x in (call-expr signed (literal-expr 32)))
      (data-port y in (call-expr signed (literal-expr 32)))
      (data-port z in (call-expr signed (literal-expr 32)))
      (data-port u out (call-expr signed (literal-expr 32)))
      (assignment (name-expr u) (register-expr (literal-expr 0) (when-clause (name-expr x))
                                               (name-expr z) (when-clause (name-expr y))))))

  (define c25-inst (C25-make))
  (slot-set! (c25-inst x) (signal 0  0   1  0  0))
  (slot-set! (c25-inst y) (signal 0  1   0  1  0))
  (slot-set! (c25-inst z) (signal 10 20  30 40 50))

  (test-case "Can register a signal with reset and enable"
    (check-sig-equal? (slot-ref c25-inst u) (signal 0  0  20 0  40) 6))

  (begin-hydromel
    (component C26
      (constant N (literal-expr 56))
      (data-port y out (call-expr signed (literal-expr 32)))
      (assignment (name-expr y) (name-expr N))))

  (define c26-inst (C26-make))

  (test-case "Can read a local constant"
    (check-sig-equal? (slot-ref c26-inst y) (signal 56) 1))

  (test-case "Can read a constant as a channel field"
    (check-equal? (slot-ref c26-inst N) 56))

  (begin-hydromel
    (interface I5
      (constant N (literal-expr 56))
      (data-port y out (call-expr signed (literal-expr 32))))

    (component C27
      (composite-port p I5)
      (assignment (field-expr (name-expr p) y) (field-expr (name-expr p) N))))

  (define c27-inst (C27-make))

  (test-case "Can read a constant from a port"
    (check-sig-equal? (slot-ref c27-inst p y) (signal 56) 1))

  (begin-hydromel
    (component C28
      (data-port y out (call-expr signed (literal-expr 32)))
      (instance c C26)
      (assignment (name-expr y) (field-expr (name-expr c) N))))

  (define c28-inst (C28-make))

  (test-case "Can read a constant from an instance"
    (check-sig-equal? (slot-ref c28-inst y) (signal 56) 1))

  (begin-hydromel
    (component C29
      (data-port y out (call-expr signed (literal-expr 32)))
      (instance c C27)
      (assignment (name-expr y) (field-expr (field-expr (name-expr c) p) N))))

  (define c29-inst (C29-make))

  (test-case "Can read a constant from an instance port"
    (check-sig-equal? (slot-ref c29-inst y) (signal 56) 1))

  (begin-hydromel
    (constant K0 (literal-expr 44))

    (component C30
      (data-port y out (call-expr signed (literal-expr 32)))
      (assignment (name-expr y) (name-expr K0))))

  (define c30-inst (C30-make))

  (test-case "Can read a global constant"
    (check-sig-equal? (slot-ref c30-inst y) (signal 44) 1))

  (begin-hydromel
    (component C31
      (constant N (literal-expr 240))
      (constant M (literal-expr -16))
      (data-port y out (call-expr unsigned (literal-expr 1)))
      (data-port z out (call-expr unsigned (literal-expr 1)))
      (data-port t out (call-expr unsigned (literal-expr 4)))
      (data-port u out (call-expr signed   (literal-expr 4)))
      (assignment (name-expr y) (slice-expr (name-expr N) (literal-expr 3)))
      (assignment (name-expr z) (slice-expr (name-expr N) (literal-expr 4)))
      (assignment (name-expr t) (slice-expr (name-expr N) (range-expr (literal-expr 5) .. (literal-expr 2))))
      (assignment (name-expr u) (slice-expr (name-expr M) (range-expr (literal-expr 5) .. (literal-expr 2))))))

  (define c31-inst (C31-make))

  (test-case "Can read a bit in an integer value"
    (check-sig-equal? (slot-ref c31-inst y) (signal 0) 1)
    (check-sig-equal? (slot-ref c31-inst z) (signal 1) 1))

  (test-case "Can read an unsigned slice in an integer value"
    (check-sig-equal? (slot-ref c31-inst t) (signal 12) 1))

  (test-case "Can read a signed slice in an integer value"
    (check-sig-equal? (slot-ref c31-inst u) (signal -4) 2))

  (begin-hydromel
    (component C32
      (data-port x in  (call-expr signed (literal-expr 4)))
      (data-port y in  (call-expr signed (literal-expr 4)))
      (data-port z out (call-expr signed (literal-expr 8)))
      (assignment (name-expr z) (concat-expr (name-expr x) (name-expr y)))))

  (define c32-inst (C32-make))
  (slot-set! (c32-inst x) (signal 0 5 -2))
  (slot-set! (c32-inst y) (signal 0 3 -4))

  (test-case "Can concatenate two integers"
    (check-sig-equal? (slot-ref c32-inst z) (signal 0 83 -20) 3))

  (begin-hydromel
    (component C33
      (data-port x in  (call-expr unsigned (literal-expr 8)))
      (data-port y out (call-expr unsigned (literal-expr 8)))
      (assignment (name-expr y) (name-expr u))
      (local-signal u (register-expr (literal-expr 0) (name-expr s)))
      (local-signal s (register-expr (literal-expr 0) (name-expr x)))))

  (define c33-inst (C33-make))

  (test-case "Can infer types when assignments are in reverse order"
    (check-equal? (actual-type (slot-type (dict-ref c33-inst 's))) (actual-type (slot-type (dict-ref c33-inst 'x))))
    (check-equal? (actual-type (slot-type (dict-ref c33-inst 'u))) (actual-type (slot-type (dict-ref c33-inst 's))))))
