#lang hydromel

interface producer(T : type)
    port valid : out bit
    port ready : in  bit
    port data  : out T
end

component mailbox(T : type, I : T)
    port c : flip producer(T)
    port p : producer(T)

    p.valid = c.valid or full
    c.ready = p.ready or not full

    signal write    = c.valid and full == p.ready
    signal full     = register(0, write or not c.ready)
    signal data_reg = register(I, c.data when write)
    p.data          = if full then data_reg else c.data
end

# full c.valid p.ready | write full* c.ready p.valid
# ---------------------|----------------------------
#   0     0       -    |   0     0       1      0
#   0     1       0    |   1     1       1      1
#   0     1       1    |   0     0       1      1
#   1     -       0    |   0     1       0      1
#   1     0       1    |   0     0       1      1
#   1     1       1    |   1     1       1      1

component fifo(T : type, I : T, N : unsigned)
    port c : flip producer(T)
    port p : producer(T)

    instance m = mailbox(T, I)
    m.c.valid = c.valid
    m.c.data  = c.data
    c.ready = m.c.ready

#    if N == 1 then
        p.valid = m.p.valid
        p.data  = m.p.data
        m.p.ready = p.ready
#    else
#        instance f = fifo(T, I, N-1)
#        f.c.valid = m.p.valid
#        f.c.data  = m.p.data
#        m.p.ready = f.c.ready
#        p.valid = f.p.valid
#        p.data  = f.p.data
#        f.p.ready = p.ready
#    end
end
