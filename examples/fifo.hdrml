#lang hydromel

interface producer(T : type)
    port valid : out bit
    port ready : in  bit
    port data  : out T
end

interface consumer_producer(T : type)
    port c : flip producer(T)
    port p : producer(T)
end

component fifo1(T : type, I : T)
    port io : splice consumer_producer(T)

    p.valid = c.valid or full
    c.ready = p.ready or not full

    signal x = not c.valid

    signal write : bit = c.valid and not (full xor p.ready)
    signal full     = register(0, write or not c.ready)
    signal data_reg = register(I, c.data when write)
    p.data          = if full then data_reg else c.data
end

# full c.valid p.ready | write full* c.ready p.valid
# ---------------------|----------------------------
#   0     0       -    |   0     0       1      0
#   0     1       0    |   1     1       1      1
#   0     1       1    |   0     0       1      1
#   1     -       0    |   0     1       0      1
#   1     0       1    |   0     0       1      1
#   1     1       1    |   1     1       1      1

component fifo2(T : type, I : T)
    port io : splice consumer_producer(T)

    instance f0 = fifo1(T, I)
    f0.c.valid  = c.valid
    f0.c.data   = c.data
    c.ready     = f0.c.ready

    instance f1 = fifo1(T, I)
    f1.c.valid  = f0.p.valid
    f1.c.data   = f0.p.data
    f0.p.ready  = f1.c.ready

    p.valid     = f1.p.valid
    p.data      = f1.p.data
    f1.p.ready  = p.ready
 end

component fifo2b(T : type, I : T)
    port io : splice consumer_producer(T)

    instance f0 = fifo1(T, I)
    instance f1 = fifo1(T, I)

    f0.c = c
    f1.c = f0.p
    p    = f1.p
end

component fifo_rec(T : type, I : T, N : unsigned)
    port io : splice consumer_producer(T)

    instance f0 = fifo1(T, I)
    f0.c.valid = c.valid
    f0.c.data  = c.data
    c.ready    = f0.c.ready

    if N == 1 then
        p.valid    = f0.p.valid
        p.data     = f0.p.data
        f0.p.ready = p.ready
    else
        instance f = fifo_rec(T, I, N-1)
        f.c.valid  = f0.p.valid
        f.c.data   = f0.p.data
        f0.p.ready = f.c.ready
        p.valid    = f.p.valid
        p.data     = f.p.data
        f.p.ready  = p.ready
    end
end

component fifo_rec_b(T : type, I : T, N : unsigned)
    port io : splice consumer_producer(T)

    instance f0 = fifo1(T, I)
    f0.c = c

    if N == 1 then
        p = f0.p
    else
        instance f = fifo_rec(T, I, N-1)
        f.c = f0.p
        p   = f.p
    end
end

component fifo_iter(T : type, I : T, N : unsigned)
    port io : splice consumer_producer(T)

    instance f[N] = fifo1(T, I)

    f[0].c.valid = c.valid
    f[0].c.data  = c.data
    c.ready      = f[0].c.ready

    for n in 1 .. N-1 loop
        f[n].c.valid   = f[n-1].p.valid
        f[n].c.data    = f[n-1].p.data
        f[n-1].p.ready = f[n].c.ready
    end

    p.valid        = f[N-1].p.valid
    p.data         = f[N-1].p.data
    f[N-1].p.ready = p.ready
end

component fifo_iter_b(T : type, I : T, N : unsigned)
    port io : splice consumer_producer(T)

    instance f[N] = fifo1(T, I)
    f[0].c = c

    for n in 1 .. N-1 loop
        f[n].c = f[n-1].p
    end

    p = f[N-1].p
end
