#lang racket

(require
  syntax/parse/define
  "expander.rkt"
  (prefix-in stx/ "syntax.rkt")
  (for-syntax
    racket
    threading
    racket/function
    racket/syntax
    syntax/parse
    syntax/parse/define
    "scope.rkt"
    (prefix-in meta/ "meta.rkt")))

(provide begin-hydromel)

(define-syntax-parse-rule (begin-hydromel body ...)
  (begin
    (compile-as-module-level-defs body) ...
    (compile-hydromel body ...)))

; First pass: bind module-level elements and manage module imports.
(define-syntax-parser compile-as-module-level-defs
  [(_ s:stx/use)
   #'(require s.path)]

  [(_ s:stx/interface)
   #:with (p ...) (port-metadata (attribute s.body))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/interface (list p ...))))]

  [(_ s:stx/component)
   #:with (p ...) (port-metadata (attribute s.body))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/component (list p ...))))]

  [_
   #'(begin)])

; Second pass:  create the scope hierarchy and bindings to local metadata (see make-checker).
; Third pass: perform semantic checking (see thunks generated by make-checker).
(define-syntax (compile-hydromel stx)
  (define/syntax-parse (_ body ...) stx)
  ((make-checker stx)))

(begin-for-syntax
  (define (boolean->syntax b)
    (if b #'#t #'#f))

  ; Second pass: fill the metadata of module-level elements.
  (define (port-metadata lst)
    (filter identity
      (for/list ([stx (in-list lst)])
        (syntax-parse stx
          [p:stx/data-port
           #'(cons 'p.name (meta/data-port 'p.mode))]
          [p:stx/composite-port
           #:with flip   (boolean->syntax (attribute p.flip?))
           #:with splice (boolean->syntax (attribute p.splice?))
           #'(cons 'p.name (meta/composite-port #'p.intf-name flip splice))]
          [_ #f]))))

  (define current-design-unit-name (make-parameter #f))

  (define current-port-table (make-parameter (make-hash)))

  (define (bind-port! name meta)
    (define name^ (bind! name meta))
    (define subtable (dict-ref (current-port-table) (current-design-unit-name)
                       (thunk
                         (define res (make-hash))
                         (dict-set! (current-port-table) (current-design-unit-name) res)
                         res)))
    (dict-set! subtable (syntax-e name^) meta)
    name^)

  (define (port-ref unit-name port-name)
    (~> (current-port-table)
        (dict-ref (syntax-e unit-name))
        (dict-ref (syntax-e port-name))))

  (define (check-all lst)
    (map (λ (f) (f)) lst))

  ; Second pass:  create the scope hierarchy and bindings to local metadata.
  ; Third pass: perform semantic checking in returned thunks.
  (define (make-checker stx)
    (syntax-parse stx
      #:literals [compile-hydromel]

      [(compile-hydromel body ...)
       (define body^ (map make-checker (attribute body)))
       (thunk
         #`(begin
             #,@(check-all body^)))]

      [s:stx/use
       (thunk #'(begin))]

      [s:stx/interface
       (define body^
         (parameterize ([current-design-unit-name (syntax-e #'s.name)])
           (with-scope
             (~>> (attribute s.body)
                  (create-aliases)
                  (map add-scope)
                  (map make-checker)))))
       (thunk/in-scope
         #`(interface s.name #,@(check-all body^)))]

      [s:stx/component
       (define body^
         (parameterize ([current-design-unit-name (syntax-e #'s.name)])
           (with-scope
             (~>> (attribute s.body)
                  (create-aliases)
                  (map add-scope)
                  (map make-checker)))))
       (thunk/in-scope
         #`(component s.name #,@(check-all body^)))]

      [s:stx/parameter
       #:with name^ (bind! #'s.name (meta/parameter))
       (thunk/in-scope
         ; TODO check type
         #'(parameter name^ s.type))]

      [s:stx/data-port
       #:with name^ (bind-port! #'s.name (meta/data-port (syntax-e #'s.mode)))
       (thunk/in-scope
         ; TODO check type
         #'(data-port name^ s.mode s.type))]

      [s:stx/composite-port
       #:with name^ (bind-port! #'s.name (meta/composite-port #'s.intf-name (attribute s.flip?) (attribute s.splice?)))
       (define mult^ (make-checker (or (attribute s.mult) #'(literal-expr 1))))
       (define args (map make-checker (attribute s.arg)))
       (thunk/in-scope
         ; Check that intf-name refers to an existing interface
         (define intf (lookup #'s.intf-name meta/interface?))
         ; Check that the multiplicity has a static value.
         (define checked-mult (mult^))
         (unless (static-value? checked-mult)
           (raise-syntax-error #f "Non-static expression cannot be used as instance multiplicity" #'s.mult))
         #`(composite-port name^ (multiplicity #,checked-mult) s.mode ... s.intf-name #,@(check-all args)))]

      [s:stx/instance
       #:with name^ (bind! #'s.name (meta/instance #'s.comp-name))
       (define mult^ (make-checker (or (attribute s.mult) #'(literal-expr 1))))
       (define args (map make-checker (attribute s.arg)))
       (thunk/in-scope
         ; Check that the multiplicity has a static value.
         (define checked-mult (mult^))
         (unless (static-value? checked-mult)
           (raise-syntax-error #f "Non-static expression cannot be used as instance multiplicity" #'s.mult))
         ; Check that comp-name refers to an existing component
         (lookup #'s.comp-name meta/component?)
         #`(instance name^ (multiplicity #,checked-mult) s.comp-name #,@(check-all args)))]

      [s:stx/constant
       #:with name^ (bind! #'s.name (meta/constant))
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define checked-expr (expr^))
         ; TODO check expression type
         ; Check that the expression has a static value.
         (unless (static-value? checked-expr)
           (raise-syntax-error #f "Non-static expression cannot be assigned to constant" #'s.expr))
         #`(constant name^ #,checked-expr))]

      [s:stx/local-signal
       #:with name^ (bind! #'s.name (meta/local-signal))
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         ; TODO check expression type
         #`(local-signal s.name #,(check-assigned-expr (expr^))))]

      [s:stx/assignment
       ; TODO support assignment from composite to composite.
       ; TODO check circular dependencies.
       (define target^ (make-checker #'s.target))
       (define expr^   (make-checker #'s.expr))
       (thunk/in-scope
         (define checked-target (target^))
         (check-assignment-target checked-target)
         #`(assignment #,checked-target #,(check-assigned-expr (expr^))))]

      [s:stx/field-expr
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define checked-expr (expr^))
         (define type-name (resolve-composite-type-name checked-expr #'s.field-name))
         #`(field-expr #,checked-expr s.field-name #,type-name))]

      [s:stx/indexed-expr
       (define expr^ (make-checker #'s.expr))
       (define indices^ (map make-checker (attribute s.index)))
       (thunk/in-scope
         ; TODO support indexed access to array data types.
         (define checked-expr (expr^))
         (define r (resolve checked-expr))
         (unless (or (meta/composite-port? r) (meta/instance? r))
           (raise-syntax-error #f "Expression not suitable for indexing" #'s.expr))
         #`(indexed-expr #,checked-expr #,@(check-all indices^)))]

      [s:stx/register-expr
       (define init-expr^   (make-checker #'s.init-expr))
       (define init-cond^   (and (attribute s.init-cond) (make-checker #'s.init-cond)))
       (define update-expr^ (make-checker #'s.update-expr))
       (define update-cond^ (and (attribute s.update-cond) (make-checker #'s.update-cond)))
       (thunk/in-scope
         (define checked-args (filter identity
                                (list
                                  (init-expr^)
                                  (and init-cond^ (init-cond^))
                                  (check-assigned-expr (update-expr^))
                                  (and update-cond^ (update-cond^)))))
         (unless (static-value? (first checked-args))
           (raise-syntax-error #f "Non-static expression cannot be used as an initial register value" #'s.init-expr))
         #`(register-expr #,@checked-args))]

      [s:stx/when-clause
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         #`(when-clause #,(check-assigned-expr (expr^))))]

      [s:stx/call-expr
       ; TODO check that fn-name is bound or built-in
       ; TODO typecheck arguments against fn
       (define args (map make-checker (attribute s.arg)))
       (thunk/in-scope
         #`(call-expr s.fn-name #,@(check-all args)))]

      [_ (thunk stx)]))

  ; Returns a list of ports in interface intf after splicing.
  (define (splice-interface intf-name flip?)
    (apply append
      (for/list ([(port-name p) (in-dict (dict-ref (current-port-table) (syntax-e intf-name)))])
        (cons
          (cons port-name (if flip? (meta/flip-port p) p))
          (if (and (meta/composite-port? p) (meta/composite-port-splice? p))
            (~> p
                (meta/composite-port-intf-name)
                (splice-interface (xor flip? (meta/composite-port-flip? p))))
            empty)))))

  ; Insert aliases for the spliced composite ports in the given list.
  (define (create-aliases lst)
    (apply append
      (for/list ([stx (in-list lst)])
        (cons stx
              (syntax-parse stx
                [s:stx/composite-port #:when (attribute s.splice?)
                 (for/list ([(port-name p) (in-dict (splice-interface #'s.intf-name (attribute s.flip?)))])
                   (define port-name^ (bind! (datum->syntax stx port-name) p))
                   #`(alias #,port-name^ s.name s.intf-name))]
                [_ empty])))))

  ; Check whether stx is an expression with a static value.
  ; Returns true when stx is:
  ; - a literal expression,
  ; - a name expression that refers to a constant,
  ; - a field expression whose left-hand side has a static value,
  ; - an indexed expression whose left-hand side and indices have static values,
  ; - a call whose arguments have static values.
  (define (static-value? stx)
    (syntax-parse stx
      [s:stx/literal-expr #t]
      [s:stx/name-expr    (meta/constant? (lookup #'s.name))]
      [s:stx/field-expr   (static-value? #'s.expr)]
      [s:stx/indexed-expr (and (static-value? #'s.expr) (andmap static-value? (attribute s.index)))]
      [s:stx/call-expr    (andmap static-value? (attribute s.arg))]
      [_                  #f]))

  ; Find the metadata of the given expression result.
  (define (resolve stx)
    (syntax-parse stx
      [s:stx/name-expr
       ; For a name expression, lookup the metadata in the current scope.
       (lookup #'s.name)]

      [s:stx/field-expr
       ; For a field expression, resolve the left-hand side first.
       (match (resolve #'s.expr)
         [(meta/composite-port intf-name _ _)
          ; If the lhs maps to a composite port, look up the given field name
          ; in the target interface.
          (meta/design-unit-ref (lookup intf-name meta/interface?) #'s.field-name)]

         [(meta/instance comp-name)
          ; If the lhs maps to an instance, look up the given field name
          ; in the target component.
          (meta/design-unit-ref (lookup comp-name meta/component?) #'s.field-name)]

         ; TODO resolve field access for structured data types

         [_ (raise-syntax-error #f "Expression not suitable for field access" stx)])]

      [s:stx/indexed-expr
       ; For an indexed expression, the metadata are those of the left-hand side.
       (resolve #'s.expr)]

      [_ #f]))

  ; Check an expression that appears in the left-hand side of an assignment.
  (define (check-assignment-target stx)
    (define (check p name thunk)
      (unless (meta/data-port? p)
        (raise-syntax-error #f "Not a port" name))
      (unless (thunk p)
        (raise-syntax-error #f "Port cannot be assigned" name)))

    (syntax-parse stx
      [s:stx/name-expr
       ; If the assignment target is a simple name, it must refer to one of these items:
       ; - a data port of the current component, with the out mode,
       ; - a data port in a spliced composite port, with the out mode if not flipped,
       ;   or with the in mode if flipped.
       ; Function splice-interface takes care of flipping the mode in spliced
       ; composite ports when needed, so we only need to check the out mode here:
       (check (lookup #'s.name)
              #'s.name
              (λ (p) (eq? 'out (meta/data-port-mode p))))]

      [s:stx/field-expr
       ; For a field expression, resolve the left-hand side first.
       (match (resolve #'s.expr)
         [(meta/composite-port intf-name flip? _)
          ; If the lhs maps to a composite port, look up the given field name
          ; in the target interface.
          ; The field name must refer to a data port with the out mode when the
          ; composite port is not flipped, or with the in mode when the composite
          ; port is flipped.
          ; Function design-unit-ref takes care of flipping the mode if the
          ; field name belongs to a flipped spliced composite port.
          (check (meta/design-unit-ref (lookup intf-name meta/interface?) #'s.field-name)
                 #'s.field-name
                 (λ (p) (xor flip? (eq? 'out (meta/data-port-mode p)))))]

         [(meta/instance comp-name)
          ; If the lhs maps to an instance, look up the given field name
          ; in the target component.
          ; The field name must refer to a data port with the in mode.
          ; Function design-unit-ref takes care of flipping the mode if the
          ; field name belongs to a flipped spliced composite port.
          (check (meta/design-unit-ref (lookup comp-name meta/component?) #'s.field-name)
                 #'s.field-name
                 (λ (p) (eq? 'in (meta/data-port-mode p))))])]

      [_ (raise-syntax-error #f "Expression not suitable as assignment target" stx)]))

  ; Check an expression that constitutes the right-hand side of an assignment.
  ; This includes:
  ; - the expression assigned to a local signal,
  ; - the update clause of a register expression,
  ; - the when clauses of a register expression.
  ; Returns an expression wrapped in lift-expr, static-expr, or signal-expr.
  (define (check-assigned-expr stx)
    (syntax-parse (lift-if-needed stx)
      [s:stx/lift-expr
       ; If a lift-expr wraps a signal read, wrap it also in a signal-expr.
       (if (meta/signal? (resolve #'s.expr))
         #'(lift-expr s.binding ... (signal-expr s.expr))
         this-syntax)]

      [_
       ; If stx has a static value, wrap it in a static-expr.
       ; If stx resolves to a signal, wrap it in a signal-expr.
       (cond [(static-value? stx)          #`(static-expr #,stx)]
             [(meta/signal? (resolve stx)) #`(signal-expr #,stx)]
             [else                         stx])]))

  (define (lift-if-needed stx)
    (syntax-parse stx
      [s:stx/call-expr    (lift-if-needed* stx (attribute s.arg)
                                           (λ (lst) #`(call-expr s.fn-name #,@lst)))]
      [s:stx/indexed-expr (lift-if-needed* stx (cons #'s.expr (attribute s.index))
                                           (λ (lst) #`(indexed-expr #,@lst)))]
      [s:stx/field-expr   (lift-if-needed* stx (list #'s.expr)
                                           (λ (lst) #`(field-expr #,(first lst) s.field-name s.type-name)))]
      [_                  stx]))

  (define (lift-if-needed* stx lst thunk)
    (for/foldr ([b-lst empty] ; The list of bindings for the new lift-expr
                [a-lst empty] ; The list of arguments for the new call-expr
                ; If there are no bindings, return the original call-expr,
                ; else, make a new call-expr wrapped in a lift-expr.
                #:result (if (empty? b-lst)
                           stx
                           #`(lift-expr #,@b-lst #,(thunk a-lst))))
                ; Lift each argument if needed before proceeding.
               ([a (in-list (map lift-if-needed lst))])
      (syntax-parse a
        [s:stx/lift-expr
         ; If the current argument is already lifted,
         ; accumulate its bindings and unwrap its expression.
         (values (append (attribute s.binding) b-lst)
                 (cons   #'s.expr              a-lst))]

        [_ #:when (meta/signal? (resolve a))
         ; If the argument resolves to a signal, wrap it in a signal-expr,
         ; create a binding and replace it with a name-expr.
         (define bname (gensym "lift"))
         (values (cons #`(#,bname (signal-expr #,a)) b-lst)
                 (cons #`(name-expr #,bname)         a-lst))]

        [_
         ; In the other cases, keep the current list of bindings
         ; and the current argument.
         (values b-lst (cons a a-lst))])))

  (define (resolve-composite-type-name expr field-name)
    (match (resolve expr)
      [(meta/composite-port intf-name _ _)
       ; Check that a port with that name exists in the interface.
       (meta/design-unit-ref (lookup intf-name meta/interface?) field-name)
       ; Return the interface name.
       intf-name]

      [(meta/instance comp-name)
       ; Check that a port with that name exists in the component.
       (meta/design-unit-ref (lookup comp-name meta/component?) field-name)
       ; Return the component name.
       comp-name]

      ; TODO support field access in structured types

      [_ (raise-syntax-error #f "Expression not suitable for field access" expr)])))


(module+ test
  (require
    rackunit
    "helpers.rkt"
    "signal.rkt")

  (begin-hydromel
    (component C0
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (name-expr x)))

    (interface I0
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer)))

    (component C1
      (composite-port i I0)
      (assignment (field-expr (name-expr i) y) (field-expr (name-expr i) x)))

    (component C2
      (composite-port i (multiplicity (literal-expr 2)) I0)
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 1)) x)))

    (interface I1
      (composite-port i (multiplicity (literal-expr 2)) I0))

    (component C3
      (composite-port j (multiplicity (literal-expr 2)) I1)
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 1)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 1)) x)))

    (component C4
      (data-port x out (name-expr integer))
      (assignment (name-expr x) (literal-expr 10)))

    (component C5
      (data-port x out (name-expr integer))
      (constant k (literal-expr 10))
      (assignment (name-expr x) (name-expr k)))

    (component C6
      (data-port x out (name-expr integer))
      (constant k (literal-expr 10))
      (assignment (name-expr x) (call-expr + (name-expr k) (literal-expr 1))))

    (component C7
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (call-expr + (name-expr x) (name-expr y))))

    (component C8
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z in (name-expr integer))
      (data-port u in (name-expr integer))
      (data-port v out (name-expr integer))
      (assignment (name-expr v) (call-expr + (call-expr * (name-expr x) (name-expr y))
                                             (call-expr * (name-expr z) (name-expr u)))))

    (component C9
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z in (name-expr integer))
      (data-port u in (name-expr integer))
      (data-port v out (name-expr integer))
      (local-signal xy (call-expr * (name-expr x) (name-expr y)))
      (local-signal zu (call-expr * (name-expr z) (name-expr u)))
      (assignment (name-expr v) (call-expr + (name-expr xy) (name-expr zu))))

    (interface I2
      (data-port x in (name-expr integer)))

    (component C10
      (composite-port i (multiplicity (literal-expr 3)) I2)
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (field-expr (indexed-expr (name-expr i) (name-expr y)) x)))

    (component C11
      (parameter N (name-expr integer))
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (call-expr * (name-expr x) (name-expr N))))

    (component C12
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c C11 (literal-expr 10))
      (assignment (field-expr (name-expr c) x) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) y)))

    (component C13
      (data-port x0 in (name-expr integer))
      (data-port x1 in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c (multiplicity (literal-expr 2)) C11 (literal-expr 10))
      (assignment (field-expr (indexed-expr (name-expr c) (literal-expr 0)) x) (name-expr x0))
      (assignment (field-expr (indexed-expr (name-expr c) (literal-expr 1)) x) (name-expr x1))
      (assignment (name-expr y) (call-expr + (field-expr (indexed-expr (name-expr c) (literal-expr 0)) y)
                                             (field-expr (indexed-expr (name-expr c) (literal-expr 1)) y))))

    (component C14
      (composite-port i splice I0)
      (assignment (name-expr y) (name-expr x)))

    (component C27
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c C14)
      (assignment (field-expr (name-expr c) x) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) y)))

    (component C24
      (composite-port i splice flip I0)
      (assignment (name-expr x) (name-expr y)))

    (component C28
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c C24)
      (assignment (field-expr (name-expr c) y) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) x)))

    (component C15
      (composite-port j splice I1)
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 1)) x)))

    (interface I3
      (composite-port i splice I0))

    (interface I4
      (composite-port i splice flip I0))

    (component C16
      (composite-port j I3)
      (assignment (field-expr (name-expr j) y) (field-expr (name-expr j) x)))

    (component C17
      (composite-port j splice I3)
      (assignment (name-expr y) (name-expr x)))

    (component C23
      (composite-port j splice flip I3)
      (assignment (name-expr x) (name-expr y)))

    (component C25
      (composite-port j splice I4)
      (assignment (name-expr x) (name-expr y)))

    (component C26
      (composite-port j splice flip I4)
      (assignment (name-expr y) (name-expr x)))

    (component C18
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (call-expr if (call-expr > (name-expr x) (name-expr y))
                                  (name-expr x)
                                  (name-expr y))))

    (component C19
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (register-expr (literal-expr 0) (name-expr x))))

    (component C20
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (register-expr (literal-expr 0) (when-clause (name-expr x))
                                               (name-expr y))))

    (component C21
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (register-expr (literal-expr 0)
                                               (name-expr y) (when-clause (name-expr x)))))

    (component C22
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z in (name-expr integer))
      (data-port u out (name-expr integer))
      (assignment (name-expr u) (register-expr (literal-expr 0) (when-clause (name-expr x))
                                               (name-expr z) (when-clause (name-expr y)))))

    (define (check-sig-equal? t e n)
      (check-equal? (signal-take t n) (signal-take e n)))

    (define .+ (signal-lift +))
    (define .* (signal-lift *))

    (test-case "Can label a simple signal expressions"
      (define c (make-instance-C0))
      (define x (signal 10))
      (port-set! (c C0-x) x)
      (check-sig-equal? (port-ref c C0-y) x 5))

    (test-case "Can resolve ports in field expressions"
      (define c (make-instance-C1))
      (define x (signal 10))
      (port-set! (c C1-i I0-x) x)
      (check-sig-equal? (port-ref c C1-i I0-y) x 5))

    (test-case "Can resolve ports in indexed expressions"
      (define c (make-instance-C2))
      (define x0 (signal 10))
      (define x1 (signal 20))
      (port-set! (c C2-i 0 I0-x) x0)
      (port-set! (c C2-i 1 I0-x) x1)
      (check-sig-equal? (port-ref c C2-i 0 I0-y) x0 5)
      (check-sig-equal? (port-ref c C2-i 1 I0-y) x1 5))

    (test-case "Can resolve ports in a hierarchy of expressions"
      (define c (make-instance-C3))
      (define x00 (signal 10))
      (define x01 (signal 20))
      (define x10 (signal 30))
      (define x11 (signal 40))
      (port-set! (c C3-j 0 I1-i 0 I0-x) x00)
      (port-set! (c C3-j 0 I1-i 1 I0-x) x01)
      (port-set! (c C3-j 1 I1-i 0 I0-x) x10)
      (port-set! (c C3-j 1 I1-i 1 I0-x) x11)
      (check-sig-equal? (port-ref c C3-j 0 I1-i 0 I0-y) x00 5)
      (check-sig-equal? (port-ref c C3-j 0 I1-i 1 I0-y) x01 5)
      (check-sig-equal? (port-ref c C3-j 1 I1-i 0 I0-y) x10 5)
      (check-sig-equal? (port-ref c C3-j 1 I1-i 1 I0-y) x11 5))

    (test-case "Can assign a literal to a signal"
      (define c (make-instance-C4))
      (check-sig-equal? (port-ref c C4-x) (signal 10) 5))

    (test-case "Can assign a constant to a signal"
      (define c (make-instance-C5))
      (check-sig-equal? (port-ref c C5-x) (signal 10) 5))

    (test-case "Can assign a static expression to a signal"
      (define c (make-instance-C6))
      (check-sig-equal? (port-ref c C6-x) (signal 11) 5))

    (test-case "Can lift an operation"
      (define c (make-instance-C7))
      (define x (list->signal (list 10 20 30)))
      (define y (list->signal (list 40 50 60)))
      (port-set! (c C7-x) x)
      (port-set! (c C7-y) y)
      (check-sig-equal? (port-ref c C7-z) (.+ x y) 5))

    (test-case "Can lift nested calls"
      (define c (make-instance-C8))
      (define x (list->signal (list 10 20 30 40 50)))
      (define y (signal 2))
      (define z (list->signal (list 1 2 3 4 5)))
      (define u (signal 3))
      (port-set! (c C8-x) x)
      (port-set! (c C8-y) y)
      (port-set! (c C8-z) z)
      (port-set! (c C8-u) u)
      (check-sig-equal? (port-ref c C8-v) (.+ (.* x y) (.* z u)) 5))

    (test-case "Can use local signals"
      (define c (make-instance-C9))
      (define x (list->signal (list 10 20 30 40 50)))
      (define y (signal 2))
      (define z (list->signal (list 1 2 3 4 5)))
      (define u (signal 3))
      (port-set! (c C9-x) x)
      (port-set! (c C9-y) y)
      (port-set! (c C9-z) z)
      (port-set! (c C9-u) u)
      (check-sig-equal? (port-ref c C9-v) (.+ (.* x y) (.* z u)) 5))

    (test-case "Can access simple ports in a vector composite port with dynamic indices"
      (define c (make-instance-C10))
      (define x0 (signal 10))
      (define x1 (signal 20))
      (define x2 (signal 30))
      (define y (list->signal (list 0 1 2 1 0 2)))
      (port-set! (c C10-i 0 I2-x) x0)
      (port-set! (c C10-i 1 I2-x) x1)
      (port-set! (c C10-i 2 I2-x) x2)
      (port-set! (c C10-y)        y)
      (define z (list->signal (list 10 20 30 20 10 30)))
      (check-sig-equal? (port-ref c C10-z) z 5))

    (test-case "Can instantiate a component"
      (define c (make-instance-C12))
      (define x (list->signal (list 10 20 30 40 50)))
      (port-set! (c C12-x) x)
      (check-sig-equal? (port-ref c C12-y) (.* x (signal 10)) 5))

    (test-case "Can instantiate a multiple component"
      (define c (make-instance-C13))
      (define x0 (list->signal (list 10 20 30 40 50)))
      (define x1 (list->signal (list 1 2 3 4 5)))
      (port-set! (c C13-x0) x0)
      (port-set! (c C13-x1) x1)
      (check-sig-equal? (port-ref c C13-y) (.* (.+ x0 x1) (signal 10)) 5))

    (test-case "Can resolve ports in a spliced interface"
      (define c (make-instance-C14))
      (define x (signal 10))
      (port-set! (c C14-x) x)
      (check-sig-equal? (port-ref c C14-y) x 5))

    (test-case "Can resolve ports in a spliced flipped interface"
      (define c (make-instance-C24))
      (define y (signal 10))
      (port-set! (c C24-y) y)
      (check-sig-equal? (port-ref c C24-x) y 5))

    (test-case "Can resolve ports in a hierarchy from a spliced interface"
      (define c (make-instance-C15))
      (define x0 (signal 10))
      (define x1 (signal 20))
      (port-set! (c C15-i 0 I0-x) x0)
      (port-set! (c C15-i 1 I0-x) x1)
      (check-sig-equal? (port-ref c C15-i 0 I0-y) x0 5)
      (check-sig-equal? (port-ref c C15-i 1 I0-y) x1 5))

    (test-case "Can resolve ports in an interface with a spliced composite port"
      (define c (make-instance-C16))
      (define x (signal 10))
      (port-set! (c C16-j I3-x) x)
      (check-sig-equal? (port-ref c C16-j I3-y) x 5))

    (test-case "Can resolve ports in a doubly spliced composite port"
      (define c (make-instance-C17))
      (define x (signal 10))
      (port-set! (c C17-x) x)
      (check-sig-equal? (port-ref c C17-y) x 5))

    (test-case "Can resolve ports in a doubly spliced flipped-last composite port"
      (define c (make-instance-C23))
      (define y (signal 10))
      (port-set! (c C23-y) y)
      (check-sig-equal? (port-ref c C23-x) y 5))

    (test-case "Can resolve ports in a doubly spliced flipped-first composite port"
      (define c (make-instance-C25))
      (define y (signal 10))
      (port-set! (c C25-y) y)
      (check-sig-equal? (port-ref c C25-x) y 5))

    (test-case "Can resolve ports in a doubly spliced doubly-flipped composite port"
      (define c (make-instance-C26))
      (define x (signal 10))
      (port-set! (c C26-x) x)
      (check-sig-equal? (port-ref c C26-y) x 5))

    (test-case "Can compute a conditional signal"
      (define c (make-instance-C18))
      (define x (list->signal (list 10 20  30 40 50)))
      (define y (list->signal (list 1  200 300 4 5)))
      (port-set! (c C18-x) x)
      (port-set! (c C18-y) y)
      (check-sig-equal? (port-ref c C18-z) ((signal-lift max) x y) 5))

    (test-case "Can register a signal"
      (define c (make-instance-C19))
      (define x (list->signal (list 10 20  30 40 50)))
      (port-set! (c C19-x) x)
      (check-sig-equal? (port-ref c C19-y) (register 0 x) 6))

    (test-case "Can register a signal with reset"
      (define c (make-instance-C20))
      (define x (list->signal (list #f #f  #f #t #f)))
      (define y (list->signal (list 10 20  30 40 50)))
      (port-set! (c C20-x) x)
      (port-set! (c C20-y) y)
      (check-sig-equal? (port-ref c C20-z) (register/r 0 x y) 6))

    (test-case "Can register a signal with enable"
      (define c (make-instance-C21))
      (define x (list->signal (list #f #t  #f #t #f)))
      (define y (list->signal (list 10 20  30 40 50)))
      (port-set! (c C21-x) x)
      (port-set! (c C21-y) y)
      (check-sig-equal? (port-ref c C21-z) (register/e 0 x y) 6))

    (test-case "Can register a signal with reset and enable"
      (define c (make-instance-C22))
      (define x (list->signal (list #f #t  #f #t #f)))
      (define y (list->signal (list #f #f  #t #f #f)))
      (define z (list->signal (list 10 20  30 40 50)))
      (port-set! (c C22-x) x)
      (port-set! (c C22-y) y)
      (port-set! (c C22-z) z)
      (check-sig-equal? (port-ref c C22-u) (register/re 0 x y z) 6))))
