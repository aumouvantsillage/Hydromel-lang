#lang racket

(require
  syntax/parse/define
  "expander.rkt"
  (prefix-in stx/ "syntax.rkt")
  (for-syntax
    racket
    threading
    racket/function
    racket/syntax
    syntax/parse
    syntax/parse/define
    "scope.rkt"
    (prefix-in meta/ "meta.rkt")))

(provide begin-hydromel)

(define-syntax-parse-rule (begin-hydromel body ...)
  (begin
    (compile-as-module-level-defs body) ...
    (compile-hydromel body ...)))

; First pass: bind module-level elements and manage module imports.
(define-syntax-parser compile-as-module-level-defs
  [(_ s:stx/import)
   (if (attribute s.name)
     (let ([prefix (format-id #'s.name "~a::" #'s.name)])
       #`(require (prefix-in #,prefix s.path)))
     #'(require s.path))]

  [(_ s:stx/constant)
   #:with alt-name (generate-temporary (format-id #'s.name "hdrml:constant:~a" #'s.name))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/constant #t)))]

  [(_ s:stx/interface)
   #:with (p ...) (design-unit-field-metadata (attribute s.body))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/make-interface (list p ...))))]

  [(_ s:stx/component)
   #:with (p ...) (design-unit-field-metadata (attribute s.body))
   #'(begin
       (provide s.name)
       (define-syntax s.name (meta/make-component (list p ...))))]

  [_
   #'(begin)])

; Second pass:  create the scope hierarchy and bindings to local metadata (see make-checker).
; Third pass: perform semantic checking (see thunks generated by make-checker).
(define-syntax (compile-hydromel stx)
  (define/syntax-parse (_ body ...) stx)
  ((make-checker stx)))

(begin-for-syntax
  (define (boolean->syntax b)
    (if b #'#t #'#f))

  ; First pass: fill the metadata of module-level elements.
  ; Those metadata are constructed as syntax objects that will be inserted
  ; into the result of compile-as-module-level-defs.
  (define (design-unit-field-metadata lst)
    (filter identity
      (for/list ([stx (in-list lst)])
        (syntax-parse stx
          [s:stx/data-port
           #'(cons 's.name (meta/data-port 's.mode))]
          [s:stx/composite-port
           #:with flip   (boolean->syntax (attribute s.flip?))
           #:with splice (boolean->syntax (attribute s.splice?))
           #'(cons 's.name (meta/composite-port #'s.intf-name flip splice))]
          [s:stx/constant
           #'(cons 's.name (meta/constant #f))]
          [_ #f]))))

  (define current-design-unit (make-parameter #f))

  (define (check-all lst)
    (map (位 (f) (f)) lst))

  ; Second pass:  create the scope hierarchy and bindings to local metadata.
  ; Third pass: perform semantic checking in returned thunks.
  (define (make-checker stx)
    (syntax-parse stx
      #:literals [compile-hydromel]

      [(compile-hydromel body ...)
       (define body^ (map make-checker (attribute body)))
       (thunk
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (begin body ...)))]

      [s:stx/import
       (thunk #'(begin))]

      [s:stx/interface
       (define body^
         (parameterize ([current-design-unit (lookup #'s.name)])
           (with-scope
             (~>> (attribute s.body)
                  (create-aliases)
                  (map add-scope)
                  (map make-checker)))))
       (thunk/in-scope
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (interface s.name body ...)))]

      [s:stx/component
       (define body^
         (parameterize ([current-design-unit (lookup #'s.name)])
           (with-scope
             (~>> (attribute s.body)
                  (create-aliases)
                  (map add-scope)
                  (map make-checker)))))
       (thunk/in-scope
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (component s.name body ...)))]

      [s:stx/parameter
       #:with name (bind! #'s.name (meta/parameter))
       (thunk/in-scope
         ; TODO check type
         (syntax/loc stx
           (parameter name s.type)))]

      [s:stx/constant
       #:with name (if (current-design-unit)
                     (bind! #'s.name (meta/design-unit-ref (current-design-unit) #'s.name))
                     #'s.name)
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse expr (expr^))
         ; TODO check expression type
         ; Check that the expression has a static value.
         (unless (static-value? #'expr)
           (raise-syntax-error #f "Non-static expression cannot be assigned to constant" #'s.expr))
         (syntax/loc stx
           (constant name expr)))]

      [s:stx/data-port
       #:with name (bind! #'s.name (meta/design-unit-ref (current-design-unit) #'s.name))
       (thunk/in-scope
         ; TODO check type
         (syntax/loc stx
           (data-port name s.mode s.type)))]

      [s:stx/composite-port
       #:with name (bind! #'s.name (meta/design-unit-ref (current-design-unit) #'s.name))
       (define mult^ (make-checker (or (attribute s.mult) #'(literal-expr 1))))
       (define args^ (map make-checker (attribute s.arg)))
       (thunk/in-scope
         ; Check that the multiplicity has a static value.
         (define/syntax-parse mult (mult^))
         (unless (static-value? #'mult)
           (raise-syntax-error #f "Non-static expression cannot be used as instance multiplicity" #'s.mult))
         ; Check that intf-name refers to an existing interface
         (lookup #'s.intf-name meta/interface?)
         ; Check arguments
         (define/syntax-parse (arg ...) (check-all args^))
         (syntax/loc stx
           (composite-port name (multiplicity mult) s.mode ... s.intf-name arg ...)))]

      [s:stx/instance
       #:with name (bind! #'s.name (meta/instance #'s.comp-name))
       (define mult^ (make-checker (or (attribute s.mult) #'(literal-expr 1))))
       (define args^ (map make-checker (attribute s.arg)))
       (thunk/in-scope
         ; Check that the multiplicity has a static value.
         (define/syntax-parse mult (mult^))
         (unless (static-value? #'mult)
           (raise-syntax-error #f "Non-static expression cannot be used as instance multiplicity" #'s.mult))
         ; Check that comp-name refers to an existing component
         (lookup #'s.comp-name meta/component?)
         ; Check arguments
         (define/syntax-parse (arg ...) (check-all args^))
         (syntax/loc stx
           (instance name (multiplicity mult) s.comp-name arg ...)))]

      [s:stx/local-signal
       #:with name (bind! #'s.name (meta/local-signal))
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         ; TODO check expression type
         (define/syntax-parse expr (check-assigned-expr (expr^)))
         (syntax/loc stx
           (local-signal name expr)))]

      [s:stx/assignment
       ; TODO support assignment from composite to composite.
       ; TODO check circular dependencies.
       (define target^ (make-checker #'s.target))
       (define expr^   (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse target (target^))
         (check-assignment-target #'target)
         (define/syntax-parse expr (check-assigned-expr (expr^)))
         (syntax/loc stx
           (assignment target expr)))]

      [s:stx/if-statement
       (define conditions^  (map make-checker (attribute s.condition)))
       (define then-bodies^ (map make-checker (attribute s.then-body)))
       (define else-body^   (make-checker     (attribute s.else-body)))
       (thunk/in-scope
         (define/syntax-parse (condition ...) (check-all conditions^))
         (define/syntax-parse (then-body ...) (check-all then-bodies^))
         (define/syntax-parse else-body       (else-body^))
         (syntax/loc stx
           (if-statement (~@ condition then-body) ... else-body)))]

      [s:stx/statement-block
       (define body^ (with-scope
                       (~>> (attribute s.body)
                            (map add-scope)
                            (map make-checker))))
       (thunk/in-scope
         (define/syntax-parse (body ...) (check-all body^))
         (syntax/loc stx
           (statement-block body ...)))]

      [s:stx/field-expr
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse expr (expr^))
         (define/syntax-parse type-name (resolve-composite-type-name #'expr #'s.field-name))
         (syntax/loc stx
           (field-expr expr s.field-name type-name)))]

      [s:stx/indexed-expr
       (define expr^ (make-checker #'s.expr))
       (define indices^ (map make-checker (attribute s.index)))
       (thunk/in-scope
         ; TODO support indexed access to array data types.
         (define/syntax-parse expr (expr^))
         (define r (resolve #'expr))
         (unless (or (meta/composite-port? r) (meta/instance? r))
           (raise-syntax-error #f "Expression not suitable for indexing" #'s.expr))
         (define/syntax-parse (index ...) (check-all indices^))
         (syntax/loc stx
           (indexed-expr expr index ...)))]

      [s:stx/register-expr
       (define init-expr^   (make-checker #'s.init-expr))
       (define init-cond^   (and (attribute s.init-cond) (make-checker #'s.init-cond)))
       (define update-expr^ (make-checker #'s.update-expr))
       (define update-cond^ (and (attribute s.update-cond) (make-checker #'s.update-cond)))
       (thunk/in-scope
         (define init-expr (init-expr^))
         (unless (static-value? init-expr)
           (raise-syntax-error #f "Non-static expression cannot be used as an initial register value" #'s.init-expr))
         (define/syntax-parse (arg ...) (filter identity
                                          (list
                                            init-expr
                                            (and init-cond^ (init-cond^))
                                            (check-assigned-expr (update-expr^))
                                            (and update-cond^ (update-cond^)))))
         (syntax/loc stx
           (register-expr arg ...)))]

      [s:stx/when-clause
       (define expr^ (make-checker #'s.expr))
       (thunk/in-scope
         (define/syntax-parse expr (check-assigned-expr (expr^)))
         (syntax/loc stx
           (when-clause expr)))]

      [s:stx/call-expr
       ; TODO check that fn-name is bound or built-in
       ; TODO typecheck arguments against fn
       (define args^ (map make-checker (attribute s.arg)))
       (thunk/in-scope
         (define/syntax-parse (arg ...) (check-all args^))
         (syntax/loc stx
           (call-expr s.fn-name arg ...)))]

      [s:stx/name-expr
       (thunk
         (define meta (lookup #'s.name))
         (if (and (meta/constant? meta) (meta/constant-global? meta))
           (syntax/loc stx
             (name-expr s.name -constant))
           stx))]

      [_ (thunk stx)]))

  ; Returns a list of ports in interface intf after splicing.
  (define (splice-interface intf flip?)
    (apply append
      (for/list ([(field-name field) (in-dict (meta/design-unit-fields intf))])
        (cons
          (cons field-name (if flip? (meta/flip-port field) field))
          (if (and (meta/composite-port? field) (meta/composite-port-splice? field))
            (~> field
                (meta/composite-port-intf-name)
                (lookup meta/interface?)
                (splice-interface (xor flip? (meta/composite-port-flip? field))))
            empty)))))

  ; Insert aliases for the spliced composite ports in the given list.
  (define (create-aliases lst)
    (apply append
      (for/list ([stx (in-list lst)])
        (cons stx
              (syntax-parse stx
                [s:stx/composite-port #:when (attribute s.splice?)
                 (define intf (lookup #'s.intf-name meta/interface?))
                 (for/list ([(port-name p) (in-dict (splice-interface intf (attribute s.flip?)))])
                   (define/syntax-parse port-name^ (bind! (datum->syntax stx port-name) p))
                   #'(alias port-name^ s.name s.intf-name))]
                [_ empty])))))

  ; Check whether stx is an expression with a static value.
  ; Returns true when stx is:
  ; - a literal expression,
  ; - a name expression that refers to a constant or a parameter,
  ; - a field expression whose left-hand side has a static value,
  ; - an indexed expression whose left-hand side and indices have static values,
  ; - a call whose arguments have static values.
  (define (static-value? stx)
    (syntax-parse stx
      [s:stx/literal-expr #t]
      [s:stx/name-expr    (define c (lookup #'s.name)) (or (meta/constant? c) (meta/parameter? c))]
      [s:stx/field-expr   (or (static-value? #'s.expr) (meta/constant? (resolve stx)))]
      [s:stx/indexed-expr (and (static-value? #'s.expr) (andmap static-value? (attribute s.index)))]
      [s:stx/call-expr    (andmap static-value? (attribute s.arg))]
      [_                  #f]))

  ; Find the metadata of the given expression result.
  (define (resolve stx)
    (syntax-parse stx
      [s:stx/name-expr
       ; For a name expression, lookup the metadata in the current scope.
       (lookup #'s.name)]

      [s:stx/field-expr
       ; For a field expression, resolve the left-hand side first.
       (match (resolve #'s.expr)
         [(meta/composite-port intf-name _ _)
          ; If the lhs maps to a composite port, look up the given field name
          ; in the target interface.
          (meta/design-unit-ref (lookup intf-name meta/interface?) #'s.field-name)]

         [(meta/instance comp-name)
          ; If the lhs maps to an instance, look up the given field name
          ; in the target component.
          (meta/design-unit-ref (lookup comp-name meta/component?) #'s.field-name)]

         ; TODO resolve field access for structured data types

         [_ (raise-syntax-error #f "Expression not suitable for field access" stx)])]

      [s:stx/indexed-expr
       ; For an indexed expression, the metadata are those of the left-hand side.
       (resolve #'s.expr)]

      [_ #f]))

  ; Check an expression that appears in the left-hand side of an assignment.
  (define (check-assignment-target stx)
    (match (resolve stx)
      ; If the left-hand side of an assignment resolves to a data port,
      ; check the mode of this port.
      [(meta/data-port mode)
       (define (flip? stx [res #f])
         (syntax-parse stx
           [s:stx/field-expr
            (define res^ (flip? #'s.expr res))
            (match (resolve #'s.expr)
              [(meta/composite-port _ f? _) (xor f? res^)]
              [(meta/instance _) (not res^)])]
           [_ res]))
       (unless (equal? mode (if (flip? stx) 'in 'out))
         (raise-syntax-error #f "Port cannot be assigned" stx))]

      ; TODO If the left-hand side resolves to a composite port,
      ; check that the right-hand side has the same interface.
      [(meta/composite-port intf-name flip? splice?)
       (raise-syntax-error #f "Assignment to composite port is not supported yet" stx)]

      [_ (raise-syntax-error #f "Expression not suitable as assignment target" stx)]))

  (define-syntax-parse-rule (qs/l expr)
    (quasisyntax/loc this-syntax expr))

  ; Check an expression that constitutes the right-hand side of an assignment.
  ; This includes:
  ; - the expression assigned to a local signal,
  ; - the update clause of a register expression,
  ; - the when clauses of a register expression.
  ; Returns an expression wrapped in lift-expr, static-expr, or signal-expr.
  (define (check-assigned-expr stx)
    (syntax-parse (lift-if-needed stx)
      [s:stx/lift-expr
       ; If a lift-expr wraps a signal read, wrap it also in a signal-expr.
       (if (meta/signal? (resolve #'s.expr))
         #'(lift-expr s.binding ... (signal-expr s.expr))
         this-syntax)]

      [_
       ; If stx has a static value, wrap it in a static-expr.
       ; If stx resolves to a signal, wrap it in a signal-expr.
       (cond [(static-value? stx)          (qs/l (static-expr #,stx))]
             [(meta/signal? (resolve stx)) (qs/l (signal-expr #,stx))]
             [else                         stx])]))

  (define (lift-if-needed stx)
    (syntax-parse stx
      [s:stx/call-expr    (lift-if-needed* stx (attribute s.arg)
                                           (位 (lst) (qs/l (call-expr s.fn-name #,@lst))))]
      [s:stx/indexed-expr (lift-if-needed* stx (cons #'s.expr (attribute s.index))
                                           (位 (lst) (qs/l (indexed-expr #,@lst))))]
      [s:stx/field-expr   (lift-if-needed* stx (list #'s.expr)
                                           (位 (lst) (qs/l (field-expr #,(first lst) s.field-name s.type-name))))]
      [_                  stx]))

  (define (lift-if-needed* stx lst thunk)
    (for/foldr ([b-lst empty] ; The list of bindings for the new lift-expr
                [a-lst empty] ; The list of arguments for the new call-expr
                ; If there are no bindings, return the original call-expr,
                ; else, make a new call-expr wrapped in a lift-expr.
                #:result (if (empty? b-lst)
                           stx
                           (quasisyntax/loc stx
                             (lift-expr #,@b-lst #,(thunk a-lst)))))
                ; Lift each argument if needed before proceeding.
               ([a (in-list (map lift-if-needed lst))])
      (syntax-parse a
        [s:stx/lift-expr
         ; If the current argument is already lifted,
         ; accumulate its bindings and unwrap its expression.
         (values (append (attribute s.binding) b-lst)
                 (cons   #'s.expr              a-lst))]

        [_ #:when (meta/signal? (resolve a))
         ; If the argument resolves to a signal, wrap it in a signal-expr,
         ; create a binding and replace it with a name-expr.
         #:with bname (gensym "lift")
         (values (cons #`(bname (signal-expr #,a)) b-lst)
                 (cons #'(name-expr bname)         a-lst))]

        [_
         ; In the other cases, keep the current list of bindings
         ; and the current argument.
         (values b-lst (cons a a-lst))])))

  (define (resolve-composite-type-name expr field-name)
    (match (resolve expr)
      [(meta/composite-port intf-name _ _)
       ; Check that a port with that name exists in the interface.
       (meta/design-unit-ref (lookup intf-name meta/interface?) field-name)
       ; Return the interface name.
       intf-name]

      [(meta/instance comp-name)
       ; Check that a port with that name exists in the component.
       (meta/design-unit-ref (lookup comp-name meta/component?) field-name)
       ; Return the component name.
       comp-name]

      ; TODO support field access in structured types

      [_ (raise-syntax-error #f "Expression not suitable for field access" expr)])))


(module+ test
  (require
    rackunit
    "helpers.rkt"
    "signal.rkt")

  (begin-hydromel
    (component C0
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (name-expr x)))

    (interface I0
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer)))

    (component C1
      (composite-port i I0)
      (assignment (field-expr (name-expr i) y) (field-expr (name-expr i) x)))

    (component C2
      (composite-port i (multiplicity (literal-expr 2)) I0)
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 1)) x)))

    (interface I1
      (composite-port i (multiplicity (literal-expr 2)) I0))

    (component C3
      (composite-port j (multiplicity (literal-expr 2)) I1)
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 0)) i) (literal-expr 1)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (field-expr (indexed-expr (name-expr j) (literal-expr 1)) i) (literal-expr 1)) x)))

    (component C4
      (data-port x out (name-expr integer))
      (assignment (name-expr x) (literal-expr 10)))

    (component C5
      (data-port x out (name-expr integer))
      (constant k (literal-expr 10))
      (assignment (name-expr x) (name-expr k)))

    (component C6
      (data-port x out (name-expr integer))
      (constant k (literal-expr 10))
      (assignment (name-expr x) (call-expr + (name-expr k) (literal-expr 1))))

    (component C7
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (call-expr + (name-expr x) (name-expr y))))

    (component C8
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z in (name-expr integer))
      (data-port u in (name-expr integer))
      (data-port v out (name-expr integer))
      (assignment (name-expr v) (call-expr + (call-expr * (name-expr x) (name-expr y))
                                             (call-expr * (name-expr z) (name-expr u)))))

    (component C9
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z in (name-expr integer))
      (data-port u in (name-expr integer))
      (data-port v out (name-expr integer))
      (local-signal xy (call-expr * (name-expr x) (name-expr y)))
      (local-signal zu (call-expr * (name-expr z) (name-expr u)))
      (assignment (name-expr v) (call-expr + (name-expr xy) (name-expr zu))))

    (interface I2
      (data-port x in (name-expr integer)))

    (component C10
      (composite-port i (multiplicity (literal-expr 3)) I2)
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (field-expr (indexed-expr (name-expr i) (name-expr y)) x)))

    (component C11
      (parameter N (name-expr integer))
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (call-expr * (name-expr x) (name-expr N))))

    (component C12
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c C11 (literal-expr 10))
      (assignment (field-expr (name-expr c) x) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) y)))

    (component C13
      (data-port x0 in (name-expr integer))
      (data-port x1 in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c (multiplicity (literal-expr 2)) C11 (literal-expr 10))
      (assignment (field-expr (indexed-expr (name-expr c) (literal-expr 0)) x) (name-expr x0))
      (assignment (field-expr (indexed-expr (name-expr c) (literal-expr 1)) x) (name-expr x1))
      (assignment (name-expr y) (call-expr + (field-expr (indexed-expr (name-expr c) (literal-expr 0)) y)
                                             (field-expr (indexed-expr (name-expr c) (literal-expr 1)) y))))

    (component C14
      (composite-port i splice I0)
      (assignment (name-expr y) (name-expr x)))

    (component C27
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c C14)
      (assignment (field-expr (name-expr c) x) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) y)))

    (component C24
      (composite-port i splice flip I0)
      (assignment (name-expr x) (name-expr y)))

    (component C28
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (instance c C24)
      (assignment (field-expr (name-expr c) y) (name-expr x))
      (assignment (name-expr y) (field-expr (name-expr c) x)))

    (component C15
      (composite-port j splice I1)
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 0)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 0)) x))
      (assignment (field-expr (indexed-expr (name-expr i) (literal-expr 1)) y)
                  (field-expr (indexed-expr (name-expr i) (literal-expr 1)) x)))

    (interface I3
      (composite-port i splice I0))

    (interface I4
      (composite-port i splice flip I0))

    (component C16
      (composite-port j I3)
      (assignment (field-expr (name-expr j) y) (field-expr (name-expr j) x)))

    (component C17
      (composite-port j splice I3)
      (assignment (name-expr y) (name-expr x)))

    (component C23
      (composite-port j splice flip I3)
      (assignment (name-expr x) (name-expr y)))

    (component C25
      (composite-port j splice I4)
      (assignment (name-expr x) (name-expr y)))

    (component C26
      (composite-port j splice flip I4)
      (assignment (name-expr y) (name-expr x)))

    (component C18
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (call-expr if (call-expr > (name-expr x) (name-expr y))
                                  (name-expr x)
                                  (name-expr y))))

    (component C19
      (data-port x in (name-expr integer))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (register-expr (literal-expr 0) (name-expr x))))

    (component C20
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (register-expr (literal-expr 0) (when-clause (name-expr x))
                                               (name-expr y))))

    (component C21
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z out (name-expr integer))
      (assignment (name-expr z) (register-expr (literal-expr 0)
                                               (name-expr y) (when-clause (name-expr x)))))

    (component C22
      (data-port x in (name-expr integer))
      (data-port y in (name-expr integer))
      (data-port z in (name-expr integer))
      (data-port u out (name-expr integer))
      (assignment (name-expr u) (register-expr (literal-expr 0) (when-clause (name-expr x))
                                               (name-expr z) (when-clause (name-expr y)))))

    (component C29
      (constant N (literal-expr 56))
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (name-expr N)))

    (interface I5
      (constant N (literal-expr 56))
      (data-port y out (name-expr integer)))

    (component C30
      (composite-port p I5)
      (assignment (field-expr (name-expr p) y) (field-expr (name-expr p) N)))

    (component C31
      (data-port y out (name-expr integer))
      (instance c C29)
      (assignment (name-expr y) (field-expr (name-expr c) N)))

    (component C32
      (data-port y out (name-expr integer))
      (instance c C30)
      (assignment (name-expr y) (field-expr (field-expr (name-expr c) p) N)))

    (constant K (literal-expr 44))

    (component C33
      (data-port y out (name-expr integer))
      (assignment (name-expr y) (name-expr K)))

    (define (check-sig-equal? t e n)
      (check-equal? (signal-take t n) (signal-take e n)))

    (define .+ (signal-lift +))
    (define .* (signal-lift *))

    (test-case "Can label a simple signal expressions"
      (define c (C0-make-instance))
      (define x (signal 10))
      (port-set! (c C0-x) x)
      (check-sig-equal? (port-ref c C0-y) x 5))

    (test-case "Can resolve ports in field expressions"
      (define c (C1-make-instance))
      (define x (signal 10))
      (port-set! (c C1-i I0-x) x)
      (check-sig-equal? (port-ref c C1-i I0-y) x 5))

    (test-case "Can resolve ports in indexed expressions"
      (define c (C2-make-instance))
      (define x0 (signal 10))
      (define x1 (signal 20))
      (port-set! (c C2-i 0 I0-x) x0)
      (port-set! (c C2-i 1 I0-x) x1)
      (check-sig-equal? (port-ref c C2-i 0 I0-y) x0 5)
      (check-sig-equal? (port-ref c C2-i 1 I0-y) x1 5))

    (test-case "Can resolve ports in a hierarchy of expressions"
      (define c (C3-make-instance))
      (define x00 (signal 10))
      (define x01 (signal 20))
      (define x10 (signal 30))
      (define x11 (signal 40))
      (port-set! (c C3-j 0 I1-i 0 I0-x) x00)
      (port-set! (c C3-j 0 I1-i 1 I0-x) x01)
      (port-set! (c C3-j 1 I1-i 0 I0-x) x10)
      (port-set! (c C3-j 1 I1-i 1 I0-x) x11)
      (check-sig-equal? (port-ref c C3-j 0 I1-i 0 I0-y) x00 5)
      (check-sig-equal? (port-ref c C3-j 0 I1-i 1 I0-y) x01 5)
      (check-sig-equal? (port-ref c C3-j 1 I1-i 0 I0-y) x10 5)
      (check-sig-equal? (port-ref c C3-j 1 I1-i 1 I0-y) x11 5))

    (test-case "Can assign a literal to a signal"
      (define c (C4-make-instance))
      (check-sig-equal? (port-ref c C4-x) (signal 10) 5))

    (test-case "Can assign a constant to a signal"
      (define c (C5-make-instance))
      (check-sig-equal? (port-ref c C5-x) (signal 10) 5))

    (test-case "Can assign a static expression to a signal"
      (define c (C6-make-instance))
      (check-sig-equal? (port-ref c C6-x) (signal 11) 5))

    (test-case "Can lift an operation"
      (define c (C7-make-instance))
      (define x (list->signal (list 10 20 30)))
      (define y (list->signal (list 40 50 60)))
      (port-set! (c C7-x) x)
      (port-set! (c C7-y) y)
      (check-sig-equal? (port-ref c C7-z) (.+ x y) 5))

    (test-case "Can lift nested calls"
      (define c (C8-make-instance))
      (define x (list->signal (list 10 20 30 40 50)))
      (define y (signal 2))
      (define z (list->signal (list 1 2 3 4 5)))
      (define u (signal 3))
      (port-set! (c C8-x) x)
      (port-set! (c C8-y) y)
      (port-set! (c C8-z) z)
      (port-set! (c C8-u) u)
      (check-sig-equal? (port-ref c C8-v) (.+ (.* x y) (.* z u)) 5))

    (test-case "Can use local signals"
      (define c (C9-make-instance))
      (define x (list->signal (list 10 20 30 40 50)))
      (define y (signal 2))
      (define z (list->signal (list 1 2 3 4 5)))
      (define u (signal 3))
      (port-set! (c C9-x) x)
      (port-set! (c C9-y) y)
      (port-set! (c C9-z) z)
      (port-set! (c C9-u) u)
      (check-sig-equal? (port-ref c C9-v) (.+ (.* x y) (.* z u)) 5))

    (test-case "Can access simple ports in a vector composite port with dynamic indices"
      (define c (C10-make-instance))
      (define x0 (signal 10))
      (define x1 (signal 20))
      (define x2 (signal 30))
      (define y (list->signal (list 0 1 2 1 0 2)))
      (port-set! (c C10-i 0 I2-x) x0)
      (port-set! (c C10-i 1 I2-x) x1)
      (port-set! (c C10-i 2 I2-x) x2)
      (port-set! (c C10-y)        y)
      (define z (list->signal (list 10 20 30 20 10 30)))
      (check-sig-equal? (port-ref c C10-z) z 5))

    (test-case "Can instantiate a component"
      (define c (C12-make-instance))
      (define x (list->signal (list 10 20 30 40 50)))
      (port-set! (c C12-x) x)
      (check-sig-equal? (port-ref c C12-y) (.* x (signal 10)) 5))

    (test-case "Can instantiate a multiple component"
      (define c (C13-make-instance))
      (define x0 (list->signal (list 10 20 30 40 50)))
      (define x1 (list->signal (list 1 2 3 4 5)))
      (port-set! (c C13-x0) x0)
      (port-set! (c C13-x1) x1)
      (check-sig-equal? (port-ref c C13-y) (.* (.+ x0 x1) (signal 10)) 5))

    (test-case "Can resolve ports in a spliced interface"
      (define c (C14-make-instance))
      (define x (signal 10))
      (port-set! (c C14-x) x)
      (check-sig-equal? (port-ref c C14-y) x 5))

    (test-case "Can resolve ports in a spliced flipped interface"
      (define c (C24-make-instance))
      (define y (signal 10))
      (port-set! (c C24-y) y)
      (check-sig-equal? (port-ref c C24-x) y 5))

    (test-case "Can resolve ports in a hierarchy from a spliced interface"
      (define c (C15-make-instance))
      (define x0 (signal 10))
      (define x1 (signal 20))
      (port-set! (c C15-i 0 I0-x) x0)
      (port-set! (c C15-i 1 I0-x) x1)
      (check-sig-equal? (port-ref c C15-i 0 I0-y) x0 5)
      (check-sig-equal? (port-ref c C15-i 1 I0-y) x1 5))

    (test-case "Can resolve ports in an interface with a spliced composite port"
      (define c (C16-make-instance))
      (define x (signal 10))
      (port-set! (c C16-j I3-x) x)
      (check-sig-equal? (port-ref c C16-j I3-y) x 5))

    (test-case "Can resolve ports in a doubly spliced composite port"
      (define c (C17-make-instance))
      (define x (signal 10))
      (port-set! (c C17-x) x)
      (check-sig-equal? (port-ref c C17-y) x 5))

    (test-case "Can resolve ports in a doubly spliced flipped-last composite port"
      (define c (C23-make-instance))
      (define y (signal 10))
      (port-set! (c C23-y) y)
      (check-sig-equal? (port-ref c C23-x) y 5))

    (test-case "Can resolve ports in a doubly spliced flipped-first composite port"
      (define c (C25-make-instance))
      (define y (signal 10))
      (port-set! (c C25-y) y)
      (check-sig-equal? (port-ref c C25-x) y 5))

    (test-case "Can resolve ports in a doubly spliced doubly-flipped composite port"
      (define c (C26-make-instance))
      (define x (signal 10))
      (port-set! (c C26-x) x)
      (check-sig-equal? (port-ref c C26-y) x 5))

    (test-case "Can compute a conditional signal"
      (define c (C18-make-instance))
      (define x (list->signal (list 10 20  30 40 50)))
      (define y (list->signal (list 1  200 300 4 5)))
      (port-set! (c C18-x) x)
      (port-set! (c C18-y) y)
      (check-sig-equal? (port-ref c C18-z) ((signal-lift max) x y) 5))

    (test-case "Can register a signal"
      (define c (C19-make-instance))
      (define x (list->signal (list 10 20  30 40 50)))
      (port-set! (c C19-x) x)
      (check-sig-equal? (port-ref c C19-y) (register 0 x) 6))

    (test-case "Can register a signal with reset"
      (define c (C20-make-instance))
      (define x (list->signal (list #f #f  #f #t #f)))
      (define y (list->signal (list 10 20  30 40 50)))
      (port-set! (c C20-x) x)
      (port-set! (c C20-y) y)
      (check-sig-equal? (port-ref c C20-z) (register/r 0 x y) 6))

    (test-case "Can register a signal with enable"
      (define c (C21-make-instance))
      (define x (list->signal (list #f #t  #f #t #f)))
      (define y (list->signal (list 10 20  30 40 50)))
      (port-set! (c C21-x) x)
      (port-set! (c C21-y) y)
      (check-sig-equal? (port-ref c C21-z) (register/e 0 x y) 6))

    (test-case "Can register a signal with reset and enable"
      (define c (C22-make-instance))
      (define x (list->signal (list #f #t  #f #t #f)))
      (define y (list->signal (list #f #f  #t #f #f)))
      (define z (list->signal (list 10 20  30 40 50)))
      (port-set! (c C22-x) x)
      (port-set! (c C22-y) y)
      (port-set! (c C22-z) z)
      (check-sig-equal? (port-ref c C22-u) (register/re 0 x y z) 6))

    (test-case "Can read a local constant"
      (define c (C29-make-instance))
      (check-sig-equal? (port-ref c C29-y) (signal 56) 1))

    (test-case "Can read a constant as a channel field"
      (define c (C29-make-instance))
      (check-equal? (C29-N c) 56))

    (test-case "Can read a constant from a port"
      (define c (C30-make-instance))
      (check-sig-equal? (port-ref c C30-p I5-y) (signal 56) 1))

    (test-case "Can read a constant from an instance"
      (define c (C31-make-instance))
      (check-sig-equal? (port-ref c C31-y) (signal 56) 1))

    (test-case "Can read a constant from an instance port"
      (define c (C32-make-instance))
      (check-sig-equal? (port-ref c C32-y) (signal 56) 1))

    (test-case "Can read a global constant"
      (define c (C33-make-instance))
      (check-sig-equal? (port-ref c C33-y) (signal 44) 1))))
